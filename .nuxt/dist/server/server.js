module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// require() chunk loading for javascript
/******/
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] !== 0) {
/******/ 			var chunk = require("./" + ({"1":"components/v-form","2":"components/v-header","3":"components/v-hero","4":"components/v-popup","5":"components/v-rewards","6":"components/v-select","7":"components/v-timer","8":"pages/index"}[chunkId]||chunkId) + ".js");
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids;
/******/ 			for(var moduleId in moreModules) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/_nuxt/";
/******/
/******/ 	// uncaught error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using import().catch()
/******/ 		});
/******/ 	};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("vue");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("ufo");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27);
/**
  * vee-validate v3.4.14
  * (c) 2021 Abdelrahman Awad
  * @license MIT
  */
(function (global, factory) {
   true ? factory(exports, __webpack_require__(0)) : undefined;
})(this, function (exports, Vue) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }
  var Vue__default = /*#__PURE__*/_interopDefaultLegacy(Vue);

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var __assign = function () {
    __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
    return r;
  }
  function isNaN(value) {
    // NaN is the one value that does not equal itself.
    // eslint-disable-next-line
    return value !== value;
  }
  function isNullOrUndefined(value) {
    return value === null || value === undefined;
  }
  function isEmptyArray(arr) {
    return Array.isArray(arr) && arr.length === 0;
  }
  var isObject = function (obj) {
    return obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);
  };
  /**
   * A reference comparison function with NaN support
   */
  function isRefEqual(lhs, rhs) {
    if (isNaN(lhs) && isNaN(rhs)) {
      return true;
    }
    return lhs === rhs;
  }
  // Checks if a given value is not an empty string or null or undefined.
  function isSpecified(val) {
    if (val === '') {
      return false;
    }
    return !isNullOrUndefined(val);
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  function isCallable(fn) {
    return typeof fn === 'function';
  }
  function isLocator(value) {
    return isCallable(value) && !!value.__locatorRef;
  }
  function findIndex(arrayLike, predicate) {
    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
    if (isCallable(array.findIndex)) {
      return array.findIndex(predicate);
    }
    /* istanbul ignore next */
    for (var i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        return i;
      }
    }
    /* istanbul ignore next */
    return -1;
  }
  /**
   * finds the first element that satisfies the predicate callback, polyfills array.find
   */
  function find(arrayLike, predicate) {
    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
    var idx = findIndex(array, predicate);
    return idx === -1 ? undefined : array[idx];
  }
  function includes(collection, item) {
    return collection.indexOf(item) !== -1;
  }
  /**
   * Converts an array-like object to array, provides a simple polyfill for Array.from
   */
  function toArray(arrayLike) {
    if (isCallable(Array.from)) {
      return Array.from(arrayLike);
    }
    /* istanbul ignore next */
    return _copyArray(arrayLike);
  }
  /* istanbul ignore next */
  function _copyArray(arrayLike) {
    var array = [];
    var length = arrayLike.length;
    for (var i = 0; i < length; i++) {
      array.push(arrayLike[i]);
    }
    return array;
  }
  function values(obj) {
    if (isCallable(Object.values)) {
      return Object.values(obj);
    }
    // fallback to keys()
    /* istanbul ignore next */
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  }
  function merge(target, source) {
    Object.keys(source).forEach(function (key) {
      if (isObject(source[key])) {
        if (!target[key]) {
          target[key] = {};
        }
        merge(target[key], source[key]);
        return;
      }
      target[key] = source[key];
    });
    return target;
  }
  function createFlags() {
    return {
      untouched: true,
      touched: false,
      dirty: false,
      pristine: true,
      valid: false,
      invalid: false,
      validated: false,
      pending: false,
      required: false,
      changed: false,
      passed: false,
      failed: false
    };
  }
  function identity(x) {
    return x;
  }
  function debounce(fn, wait, token) {
    if (wait === void 0) {
      wait = 0;
    }
    if (token === void 0) {
      token = {
        cancelled: false
      };
    }
    if (wait === 0) {
      return fn;
    }
    var timeout;
    return function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var later = function () {
        timeout = undefined;
        // check if the fn call was cancelled.
        if (!token.cancelled) fn.apply(void 0, args);
      };
      // because we might want to use Node.js setTimout for SSR.
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  /**
   * Emits a warning to the console
   */
  function warn(message) {
    console.warn("[vee-validate] " + message);
  }
  /**
   * Replaces placeholder values in a string with their actual values
   */
  function interpolate(template, values) {
    return template.replace(/{([^}]+)}/g, function (_, p) {
      return p in values ? values[p] : "{" + p + "}";
    });
  }
  var RULES = {};
  function normalizeSchema(schema) {
    var _a;
    if ((_a = schema.params) === null || _a === void 0 ? void 0 : _a.length) {
      schema.params = schema.params.map(function (param) {
        if (typeof param === 'string') {
          return {
            name: param
          };
        }
        return param;
      });
    }
    return schema;
  }
  var RuleContainer = /** @class */function () {
    function RuleContainer() {}
    RuleContainer.extend = function (name, schema) {
      // if rule already exists, overwrite it.
      var rule = normalizeSchema(schema);
      if (RULES[name]) {
        RULES[name] = merge(RULES[name], schema);
        return;
      }
      RULES[name] = __assign({
        lazy: false,
        computesRequired: false
      }, rule);
    };
    RuleContainer.isLazy = function (name) {
      var _a;
      return !!((_a = RULES[name]) === null || _a === void 0 ? void 0 : _a.lazy);
    };
    RuleContainer.isRequireRule = function (name) {
      var _a;
      return !!((_a = RULES[name]) === null || _a === void 0 ? void 0 : _a.computesRequired);
    };
    RuleContainer.getRuleDefinition = function (ruleName) {
      return RULES[ruleName];
    };
    return RuleContainer;
  }();
  /**
   * Adds a custom validator to the list of validation rules.
   */
  function extend(name, schema) {
    // makes sure new rules are properly formatted.
    guardExtend(name, schema);
    // Full schema object.
    if (typeof schema === 'object') {
      RuleContainer.extend(name, schema);
      return;
    }
    RuleContainer.extend(name, {
      validate: schema
    });
  }
  /**
   * Guards from extension violations.
   */
  function guardExtend(name, validator) {
    if (isCallable(validator)) {
      return;
    }
    if (isCallable(validator.validate)) {
      return;
    }
    if (RuleContainer.getRuleDefinition(name)) {
      return;
    }
    throw new Error("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.");
  }
  var DEFAULT_CONFIG = {
    defaultMessage: "{_field_} is not valid.",
    skipOptional: true,
    classes: {
      touched: 'touched',
      untouched: 'untouched',
      valid: 'valid',
      invalid: 'invalid',
      pristine: 'pristine',
      dirty: 'dirty' // control has been interacted with
    },

    bails: true,
    mode: 'aggressive',
    useConstraintAttrs: true
  };
  var currentConfig = __assign({}, DEFAULT_CONFIG);
  var getConfig = function () {
    return currentConfig;
  };
  var setConfig = function (newConf) {
    currentConfig = __assign(__assign({}, currentConfig), newConf);
  };
  var configure = function (cfg) {
    setConfig(cfg);
  };

  /**
   * Normalizes the given rules expression.
   */
  function normalizeRules(rules) {
    // if falsy value return an empty object.
    var acc = {};
    Object.defineProperty(acc, '_$$isNormalized', {
      value: true,
      writable: false,
      enumerable: false,
      configurable: false
    });
    if (!rules) {
      return acc;
    }
    // Object is already normalized, skip.
    if (isObject(rules) && rules._$$isNormalized) {
      return rules;
    }
    if (isObject(rules)) {
      return Object.keys(rules).reduce(function (prev, curr) {
        var params = [];
        if (rules[curr] === true) {
          params = [];
        } else if (Array.isArray(rules[curr])) {
          params = rules[curr];
        } else if (isObject(rules[curr])) {
          params = rules[curr];
        } else {
          params = [rules[curr]];
        }
        if (rules[curr] !== false) {
          prev[curr] = buildParams(curr, params);
        }
        return prev;
      }, acc);
    }
    /* istanbul ignore if */
    if (typeof rules !== 'string') {
      warn('rules must be either a string or an object.');
      return acc;
    }
    return rules.split('|').reduce(function (prev, rule) {
      var parsedRule = parseRule(rule);
      if (!parsedRule.name) {
        return prev;
      }
      prev[parsedRule.name] = buildParams(parsedRule.name, parsedRule.params);
      return prev;
    }, acc);
  }
  function buildParams(ruleName, provided) {
    var ruleSchema = RuleContainer.getRuleDefinition(ruleName);
    if (!ruleSchema) {
      return provided;
    }
    var params = {};
    if (!ruleSchema.params && !Array.isArray(provided)) {
      throw new Error('You provided an object params to a rule that has no defined schema.');
    }
    // Rule probably uses an array for their args, keep it as is.
    if (Array.isArray(provided) && !ruleSchema.params) {
      return provided;
    }
    var definedParams;
    // collect the params schema.
    if (!ruleSchema.params || ruleSchema.params.length < provided.length && Array.isArray(provided)) {
      var lastDefinedParam_1;
      // collect any additional parameters in the last item.
      definedParams = provided.map(function (_, idx) {
        var _a;
        var param = (_a = ruleSchema.params) === null || _a === void 0 ? void 0 : _a[idx];
        lastDefinedParam_1 = param || lastDefinedParam_1;
        if (!param) {
          param = lastDefinedParam_1;
        }
        return param;
      });
    } else {
      definedParams = ruleSchema.params;
    }
    // Match the provided array length with a temporary schema.
    for (var i = 0; i < definedParams.length; i++) {
      var options = definedParams[i];
      var value = options.default;
      // if the provided is an array, map element value.
      if (Array.isArray(provided)) {
        if (i in provided) {
          value = provided[i];
        }
      } else {
        // If the param exists in the provided object.
        if (options.name in provided) {
          value = provided[options.name];
          // if the provided is the first param value.
        } else if (definedParams.length === 1) {
          value = provided;
        }
      }
      // if the param is a target, resolve the target value.
      if (options.isTarget) {
        value = createLocator(value, options.cast);
      }
      // A target param using interpolation
      if (typeof value === 'string' && value[0] === '@') {
        value = createLocator(value.slice(1), options.cast);
      }
      // If there is a transformer defined.
      if (!isLocator(value) && options.cast) {
        value = options.cast(value);
      }
      // already been set, probably multiple values.
      if (params[options.name]) {
        params[options.name] = Array.isArray(params[options.name]) ? params[options.name] : [params[options.name]];
        params[options.name].push(value);
      } else {
        // set the value.
        params[options.name] = value;
      }
    }
    return params;
  }
  /**
   * Parses a rule string expression.
   */
  var parseRule = function (rule) {
    var params = [];
    var name = rule.split(':')[0];
    if (includes(rule, ':')) {
      params = rule.split(':').slice(1).join(':').split(',');
    }
    return {
      name: name,
      params: params
    };
  };
  function createLocator(value, castFn) {
    var locator = function (crossTable) {
      var val = crossTable[value];
      return castFn ? castFn(val) : val;
    };
    locator.__locatorRef = value;
    return locator;
  }
  function extractLocators(params) {
    if (Array.isArray(params)) {
      return params.filter(function (param) {
        return isLocator(param) || typeof param === 'string' && param[0] === '@';
      });
    }
    return Object.keys(params).filter(function (key) {
      return isLocator(params[key]);
    }).map(function (key) {
      return params[key];
    });
  }

  /**
   * Validates a value against the rules.
   */
  function validate(value, rules, options) {
    if (options === void 0) {
      options = {};
    }
    return __awaiter(this, void 0, void 0, function () {
      var shouldBail, skipIfEmpty, field, result, errors, failedRules, regenerateMap;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            shouldBail = options === null || options === void 0 ? void 0 : options.bails;
            skipIfEmpty = options === null || options === void 0 ? void 0 : options.skipIfEmpty;
            field = {
              name: (options === null || options === void 0 ? void 0 : options.name) || '{field}',
              rules: normalizeRules(rules),
              bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
              skipIfEmpty: skipIfEmpty !== null && skipIfEmpty !== void 0 ? skipIfEmpty : true,
              forceRequired: false,
              crossTable: (options === null || options === void 0 ? void 0 : options.values) || {},
              names: (options === null || options === void 0 ? void 0 : options.names) || {},
              customMessages: (options === null || options === void 0 ? void 0 : options.customMessages) || {}
            };
            return [4 /*yield*/, _validate(field, value, options)];
          case 1:
            result = _a.sent();
            errors = [];
            failedRules = {};
            regenerateMap = {};
            result.errors.forEach(function (e) {
              var msg = e.msg();
              errors.push(msg);
              failedRules[e.rule] = msg;
              regenerateMap[e.rule] = e.msg;
            });
            return [2 /*return*/, {
              valid: result.valid,
              required: result.required,
              errors: errors,
              failedRules: failedRules,
              regenerateMap: regenerateMap
            }];
        }
      });
    });
  }
  /**
   * Starts the validation process.
   */
  function _validate(field, value, _a) {
    var _b = (_a === void 0 ? {} : _a).isInitial,
      isInitial = _b === void 0 ? false : _b;
    return __awaiter(this, void 0, void 0, function () {
      var _c, shouldSkip, required, errors, rules, length, i, rule, result;
      return __generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            return [4 /*yield*/, _shouldSkip(field, value)];
          case 1:
            _c = _d.sent(), shouldSkip = _c.shouldSkip, required = _c.required, errors = _c.errors;
            if (shouldSkip) {
              return [2 /*return*/, {
                valid: !errors.length,
                required: required,
                errors: errors
              }];
            }
            rules = Object.keys(field.rules).filter(function (rule) {
              return !RuleContainer.isRequireRule(rule);
            });
            length = rules.length;
            i = 0;
            _d.label = 2;
          case 2:
            if (!(i < length)) return [3 /*break*/, 5];
            if (isInitial && RuleContainer.isLazy(rules[i])) {
              return [3 /*break*/, 4];
            }
            rule = rules[i];
            return [4 /*yield*/, _test(field, value, {
              name: rule,
              params: field.rules[rule]
            })];
          case 3:
            result = _d.sent();
            if (!result.valid && result.error) {
              errors.push(result.error);
              if (field.bails) {
                return [2 /*return*/, {
                  valid: false,
                  required: required,
                  errors: errors
                }];
              }
            }
            _d.label = 4;
          case 4:
            i++;
            return [3 /*break*/, 2];
          case 5:
            return [2 /*return*/, {
              valid: !errors.length,
              required: required,
              errors: errors
            }];
        }
      });
    });
  }
  function _shouldSkip(field, value) {
    return __awaiter(this, void 0, void 0, function () {
      var requireRules, length, errors, isEmpty, isEmptyAndOptional, isRequired, i, rule, result;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);
            length = requireRules.length;
            errors = [];
            isEmpty = isNullOrUndefined(value) || value === '' || isEmptyArray(value);
            isEmptyAndOptional = isEmpty && field.skipIfEmpty;
            i = 0;
            _a.label = 1;
          case 1:
            if (!(i < length)) return [3 /*break*/, 4];
            rule = requireRules[i];
            return [4 /*yield*/, _test(field, value, {
              name: rule,
              params: field.rules[rule]
            })];
          case 2:
            result = _a.sent();
            if (!isObject(result)) {
              throw new Error('Require rules has to return an object (see docs)');
            }
            if (result.required !== undefined) {
              isRequired = result.required;
            }
            if (!result.valid && result.error) {
              errors.push(result.error);
              // Exit early as the field is required and failed validation.
              if (field.bails) {
                return [2 /*return*/, {
                  shouldSkip: true,
                  required: result.required,
                  errors: errors
                }];
              }
            }
            _a.label = 3;
          case 3:
            i++;
            return [3 /*break*/, 1];
          case 4:
            if (isEmpty && !isRequired && !field.skipIfEmpty) {
              return [2 /*return*/, {
                shouldSkip: false,
                required: isRequired,
                errors: errors
              }];
            }
            // field is configured to run through the pipeline regardless
            if (!field.bails && !isEmptyAndOptional) {
              return [2 /*return*/, {
                shouldSkip: false,
                required: isRequired,
                errors: errors
              }];
            }
            // skip if the field is not required and has an empty value.
            return [2 /*return*/, {
              shouldSkip: !isRequired && isEmpty,
              required: isRequired,
              errors: errors
            }];
        }
      });
    });
  }
  /**
   * Tests a single input value against a rule.
   */
  function _test(field, value, rule) {
    return __awaiter(this, void 0, void 0, function () {
      var ruleSchema, normalizedValue, params, result, values_1;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            ruleSchema = RuleContainer.getRuleDefinition(rule.name);
            if (!ruleSchema || !ruleSchema.validate) {
              throw new Error("No such validator '" + rule.name + "' exists.");
            }
            normalizedValue = ruleSchema.castValue ? ruleSchema.castValue(value) : value;
            params = fillTargetValues(rule.params, field.crossTable);
            return [4 /*yield*/, ruleSchema.validate(normalizedValue, params)];
          case 1:
            result = _a.sent();
            if (typeof result === 'string') {
              values_1 = __assign(__assign({}, params || {}), {
                _field_: field.name,
                _value_: value,
                _rule_: rule.name
              });
              return [2 /*return*/, {
                valid: false,
                error: {
                  rule: rule.name,
                  msg: function () {
                    return interpolate(result, values_1);
                  }
                }
              }];
            }
            if (!isObject(result)) {
              result = {
                valid: result
              };
            }
            return [2 /*return*/, {
              valid: result.valid,
              required: result.required,
              error: result.valid ? undefined : _generateFieldError(field, value, ruleSchema, rule.name, params)
            }];
        }
      });
    });
  }
  /**
   * Generates error messages.
   */
  function _generateFieldError(field, value, ruleSchema, ruleName, params) {
    var _a;
    var message = (_a = field.customMessages[ruleName]) !== null && _a !== void 0 ? _a : ruleSchema.message;
    var ruleTargets = _getRuleTargets(field, ruleSchema, ruleName);
    var _b = _getUserTargets(field, ruleSchema, ruleName, message),
      userTargets = _b.userTargets,
      userMessage = _b.userMessage;
    var values = __assign(__assign(__assign(__assign({}, params || {}), {
      _field_: field.name,
      _value_: value,
      _rule_: ruleName
    }), ruleTargets), userTargets);
    return {
      msg: function () {
        return _normalizeMessage(userMessage || getConfig().defaultMessage, field.name, values);
      },
      rule: ruleName
    };
  }
  function _getRuleTargets(field, ruleSchema, ruleName) {
    var params = ruleSchema.params;
    if (!params) {
      return {};
    }
    var numTargets = params.filter(function (param) {
      return param.isTarget;
    }).length;
    if (numTargets <= 0) {
      return {};
    }
    var names = {};
    var ruleConfig = field.rules[ruleName];
    if (!Array.isArray(ruleConfig) && isObject(ruleConfig)) {
      ruleConfig = params.map(function (param) {
        return ruleConfig[param.name];
      });
    }
    for (var index = 0; index < params.length; index++) {
      var param = params[index];
      var key = ruleConfig[index];
      if (!isLocator(key)) {
        continue;
      }
      key = key.__locatorRef;
      var name_1 = field.names[key] || key;
      names[param.name] = name_1;
      names["_" + param.name + "_"] = field.crossTable[key];
    }
    return names;
  }
  function _getUserTargets(field, ruleSchema, ruleName, userMessage) {
    var userTargets = {};
    var rules = field.rules[ruleName];
    var params = ruleSchema.params || [];
    // early return if no rules
    if (!rules) {
      return {};
    }
    // check all rules to convert targets
    Object.keys(rules).forEach(function (key, index) {
      // get the rule
      var rule = rules[key];
      if (!isLocator(rule)) {
        return {};
      }
      // get associated parameter
      var param = params[index];
      if (!param) {
        return {};
      }
      // grab the name of the target
      var name = rule.__locatorRef;
      userTargets[param.name] = field.names[name] || name;
      userTargets["_" + param.name + "_"] = field.crossTable[name];
    });
    return {
      userTargets: userTargets,
      userMessage: userMessage
    };
  }
  function _normalizeMessage(template, field, values) {
    if (typeof template === 'function') {
      return template(field, values);
    }
    return interpolate(template, __assign(__assign({}, values), {
      _field_: field
    }));
  }
  function fillTargetValues(params, crossTable) {
    if (Array.isArray(params)) {
      return params.map(function (param) {
        var targetPart = typeof param === 'string' && param[0] === '@' ? param.slice(1) : param;
        if (targetPart in crossTable) {
          return crossTable[targetPart];
        }
        return param;
      });
    }
    var values = {};
    var normalize = function (value) {
      if (isLocator(value)) {
        return value(crossTable);
      }
      return value;
    };
    Object.keys(params).forEach(function (param) {
      values[param] = normalize(params[param]);
    });
    return values;
  }
  var aggressive = function () {
    return {
      on: ['input', 'blur']
    };
  };
  var lazy = function () {
    return {
      on: ['change', 'blur']
    };
  };
  var eager = function (_a) {
    var errors = _a.errors;
    if (errors.length) {
      return {
        on: ['input', 'change']
      };
    }
    return {
      on: ['change', 'blur']
    };
  };
  var passive = function () {
    return {
      on: []
    };
  };
  var modes = {
    aggressive: aggressive,
    eager: eager,
    passive: passive,
    lazy: lazy
  };
  var setInteractionMode = function (mode, implementation) {
    setConfig({
      mode: mode
    });
    if (!implementation) {
      return;
    }
    if (!isCallable(implementation)) {
      throw new Error('A mode implementation must be a function');
    }
    modes[mode] = implementation;
  };
  var EVENT_BUS = new Vue__default['default']();
  function localeChanged() {
    EVENT_BUS.$emit('change:locale');
  }
  var Dictionary = /** @class */function () {
    function Dictionary(locale, dictionary) {
      this.container = {};
      this.locale = locale;
      this.merge(dictionary);
    }
    Dictionary.prototype.resolve = function (field, rule, values) {
      return this.format(this.locale, field, rule, values);
    };
    Dictionary.prototype.format = function (locale, field, rule, values) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var message;
      // find if specific message for that field was specified.
      var fieldContainer = (_c = (_b = (_a = this.container[locale]) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c[rule];
      var messageContainer = (_e = (_d = this.container[locale]) === null || _d === void 0 ? void 0 : _d.messages) === null || _e === void 0 ? void 0 : _e[rule];
      message = fieldContainer || messageContainer || '';
      if (!message) {
        message = '{_field_} is not valid';
      }
      field = (_h = (_g = (_f = this.container[locale]) === null || _f === void 0 ? void 0 : _f.names) === null || _g === void 0 ? void 0 : _g[field]) !== null && _h !== void 0 ? _h : field;
      return isCallable(message) ? message(field, values) : interpolate(message, __assign(__assign({}, values), {
        _field_: field
      }));
    };
    Dictionary.prototype.merge = function (dictionary) {
      merge(this.container, dictionary);
    };
    Dictionary.prototype.hasRule = function (name) {
      var _a, _b;
      return !!((_b = (_a = this.container[this.locale]) === null || _a === void 0 ? void 0 : _a.messages) === null || _b === void 0 ? void 0 : _b[name]);
    };
    return Dictionary;
  }();
  var DICTIONARY;
  function localize(locale, dictionary) {
    var _a;
    if (!DICTIONARY) {
      DICTIONARY = new Dictionary('en', {});
      setConfig({
        defaultMessage: function (field, values) {
          return DICTIONARY.resolve(field, values === null || values === void 0 ? void 0 : values._rule_, values || {});
        }
      });
    }
    if (typeof locale === 'string') {
      DICTIONARY.locale = locale;
      if (dictionary) {
        DICTIONARY.merge((_a = {}, _a[locale] = dictionary, _a));
      }
      localeChanged();
      return;
    }
    DICTIONARY.merge(locale);
  }

  // do not edit .js files directly - edit src/index.jst

  var fastDeepEqual = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b;
  };
  var isEvent = function (evt) {
    if (!evt) {
      return false;
    }
    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {
      return true;
    }
    // this is for IE
    /* istanbul ignore next */
    if (evt && evt.srcElement) {
      return true;
    }
    return false;
  };
  function normalizeEventValue(value) {
    var _a, _b;
    if (!isEvent(value)) {
      return value;
    }
    var input = value.target;
    if (input.type === 'file' && input.files) {
      return toArray(input.files);
    }
    // If the input has a `v-model.number` modifier applied.
    if ((_a = input._vModifiers) === null || _a === void 0 ? void 0 : _a.number) {
      // as per the spec the v-model.number uses parseFloat
      var valueAsNumber = parseFloat(input.value);
      if (isNaN(valueAsNumber)) {
        return input.value;
      }
      return valueAsNumber;
    }
    if ((_b = input._vModifiers) === null || _b === void 0 ? void 0 : _b.trim) {
      var trimmedValue = typeof input.value === 'string' ? input.value.trim() : input.value;
      return trimmedValue;
    }
    return input.value;
  }
  var isTextInput = function (vnode) {
    var _a;
    var attrs = ((_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs) || vnode.elm;
    // it will fallback to being a text input per browsers spec.
    if (vnode.tag === 'input' && (!attrs || !attrs.type)) {
      return true;
    }
    if (vnode.tag === 'textarea') {
      return true;
    }
    return includes(['text', 'password', 'search', 'email', 'tel', 'url', 'number'], attrs === null || attrs === void 0 ? void 0 : attrs.type);
  };
  // export const isCheckboxOrRadioInput = (vnode: VNode): boolean => {
  //   const attrs = (vnode.data && vnode.data.attrs) || vnode.elm;
  //   return includes(['radio', 'checkbox'], attrs && attrs.type);
  // };
  // Gets the model object on the vnode.
  function findModel(vnode) {
    if (!vnode.data) {
      return undefined;
    }
    // Component Model
    // THIS IS NOT TYPED IN OFFICIAL VUE TYPINGS
    // eslint-disable-next-line
    var nonStandardVNodeData = vnode.data;
    if ('model' in nonStandardVNodeData) {
      return nonStandardVNodeData.model;
    }
    if (!vnode.data.directives) {
      return undefined;
    }
    return find(vnode.data.directives, function (d) {
      return d.name === 'model';
    });
  }
  function findValue(vnode) {
    var _a, _b;
    var model = findModel(vnode);
    if (model) {
      return {
        value: model.value
      };
    }
    var config = findModelConfig(vnode);
    var prop = (config === null || config === void 0 ? void 0 : config.prop) || 'value';
    if (((_a = vnode.componentOptions) === null || _a === void 0 ? void 0 : _a.propsData) && prop in vnode.componentOptions.propsData) {
      var propsDataWithValue = vnode.componentOptions.propsData;
      return {
        value: propsDataWithValue[prop]
      };
    }
    if (((_b = vnode.data) === null || _b === void 0 ? void 0 : _b.domProps) && 'value' in vnode.data.domProps) {
      return {
        value: vnode.data.domProps.value
      };
    }
    return undefined;
  }
  function extractChildren(vnode) {
    if (Array.isArray(vnode)) {
      return vnode;
    }
    if (Array.isArray(vnode.children)) {
      return vnode.children;
    }
    /* istanbul ignore next */
    if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {
      return vnode.componentOptions.children;
    }
    return [];
  }
  function findInputNodes(vnode) {
    if (!Array.isArray(vnode) && findValue(vnode) !== undefined) {
      return [vnode];
    }
    var children = extractChildren(vnode);
    return children.reduce(function (nodes, node) {
      var candidates = findInputNodes(node);
      if (candidates.length) {
        nodes.push.apply(nodes, candidates);
      }
      return nodes;
    }, []);
  }
  // Resolves v-model config if exists.
  function findModelConfig(vnode) {
    /* istanbul ignore next */
    if (!vnode.componentOptions) return null;
    // This is also not typed in the standard Vue TS.
    return vnode.componentOptions.Ctor.options.model;
  }
  // Adds a listener to vnode listener object.
  function mergeVNodeListeners(obj, eventName, handler) {
    // no listener at all.
    if (isNullOrUndefined(obj[eventName])) {
      obj[eventName] = [handler];
      return;
    }
    // Is an invoker.
    if (isCallable(obj[eventName]) && obj[eventName].fns) {
      var invoker = obj[eventName];
      invoker.fns = Array.isArray(invoker.fns) ? invoker.fns : [invoker.fns];
      if (!includes(invoker.fns, handler)) {
        invoker.fns.push(handler);
      }
      return;
    }
    if (isCallable(obj[eventName])) {
      var prev = obj[eventName];
      obj[eventName] = [prev];
    }
    if (Array.isArray(obj[eventName]) && !includes(obj[eventName], handler)) {
      obj[eventName].push(handler);
    }
  }
  // Adds a listener to a native HTML vnode.
  function addNativeNodeListener(node, eventName, handler) {
    /* istanbul ignore next */
    if (!node.data) {
      node.data = {};
    }
    if (isNullOrUndefined(node.data.on)) {
      node.data.on = {};
    }
    mergeVNodeListeners(node.data.on, eventName, handler);
  }
  // Adds a listener to a Vue component vnode.
  function addComponentNodeListener(node, eventName, handler) {
    /* istanbul ignore next */
    if (!node.componentOptions) {
      return;
    }
    /* istanbul ignore next */
    if (!node.componentOptions.listeners) {
      node.componentOptions.listeners = {};
    }
    mergeVNodeListeners(node.componentOptions.listeners, eventName, handler);
  }
  function addVNodeListener(vnode, eventName, handler) {
    if (vnode.componentOptions) {
      addComponentNodeListener(vnode, eventName, handler);
      return;
    }
    addNativeNodeListener(vnode, eventName, handler);
  }
  // Determines if `change` should be used over `input` for listeners.
  function getInputEventName(vnode, model) {
    var _a;
    // Is a component.
    if (vnode.componentOptions) {
      var event_1 = (findModelConfig(vnode) || {
        event: 'input'
      }).event;
      return event_1;
    }
    // Lazy Models typically use change event
    if ((_a = model === null || model === void 0 ? void 0 : model.modifiers) === null || _a === void 0 ? void 0 : _a.lazy) {
      return 'change';
    }
    // is a textual-type input.
    if (isTextInput(vnode)) {
      return 'input';
    }
    return 'change';
  }
  function isHTMLNode(node) {
    return includes(['input', 'select', 'textarea'], node.tag);
  }
  // TODO: Type this one properly.
  function normalizeSlots(slots, ctx) {
    var acc = [];
    return Object.keys(slots).reduce(function (arr, key) {
      slots[key].forEach(function (vnode) {
        if (!vnode.context) {
          slots[key].context = ctx;
          if (!vnode.data) {
            vnode.data = {};
          }
          vnode.data.slot = key;
        }
      });
      return arr.concat(slots[key]);
    }, acc);
  }
  function resolveTextualRules(vnode) {
    var _a;
    var attrs = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs;
    var rules = {};
    if (!attrs) return rules;
    if (attrs.type === 'email' && RuleContainer.getRuleDefinition('email')) {
      rules.email = ['multiple' in attrs];
    }
    if (attrs.pattern && RuleContainer.getRuleDefinition('regex')) {
      rules.regex = attrs.pattern;
    }
    if (attrs.maxlength >= 0 && RuleContainer.getRuleDefinition('max')) {
      rules.max = attrs.maxlength;
    }
    if (attrs.minlength >= 0 && RuleContainer.getRuleDefinition('min')) {
      rules.min = attrs.minlength;
    }
    if (attrs.type === 'number') {
      if (isSpecified(attrs.min) && RuleContainer.getRuleDefinition('min_value')) {
        rules.min_value = Number(attrs.min);
      }
      if (isSpecified(attrs.max) && RuleContainer.getRuleDefinition('max_value')) {
        rules.max_value = Number(attrs.max);
      }
    }
    return rules;
  }
  function resolveRules(vnode) {
    var _a;
    var htmlTags = ['input', 'select', 'textarea'];
    var attrs = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs;
    if (!includes(htmlTags, vnode.tag) || !attrs) {
      return {};
    }
    var rules = {};
    if ('required' in attrs && attrs.required !== false && RuleContainer.getRuleDefinition('required')) {
      rules.required = attrs.type === 'checkbox' ? [true] : true;
    }
    if (isTextInput(vnode)) {
      return normalizeRules(__assign(__assign({}, rules), resolveTextualRules(vnode)));
    }
    return normalizeRules(rules);
  }
  function normalizeChildren(context, slotProps) {
    if (context.$scopedSlots.default) {
      return context.$scopedSlots.default(slotProps) || [];
    }
    return context.$slots.default || [];
  }

  /**
   * Determines if a provider needs to run validation.
   */
  function shouldValidate(ctx, value) {
    // when an immediate/initial validation is needed and wasn't done before.
    if (!ctx._ignoreImmediate && ctx.immediate) {
      return true;
    }
    // when the value changes for whatever reason.
    if (!isRefEqual(ctx.value, value) && ctx.normalizedEvents.length) {
      return true;
    }
    // when it needs validation due to props/cross-fields changes.
    if (ctx._needsValidation) {
      return true;
    }
    // when the initial value is undefined and the field wasn't rendered yet.
    if (!ctx.initialized && value === undefined) {
      return true;
    }
    return false;
  }
  function createValidationCtx(ctx) {
    return __assign(__assign({}, ctx.flags), {
      errors: ctx.errors,
      classes: ctx.classes,
      failedRules: ctx.failedRules,
      reset: function () {
        return ctx.reset();
      },
      validate: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return ctx.validate.apply(ctx, args);
      },
      ariaInput: {
        'aria-invalid': ctx.flags.invalid ? 'true' : 'false',
        'aria-required': ctx.isRequired ? 'true' : 'false',
        'aria-errormessage': "vee_" + ctx.id
      },
      ariaMsg: {
        id: "vee_" + ctx.id,
        'aria-live': ctx.errors.length ? 'assertive' : 'off'
      }
    });
  }
  function onRenderUpdate(vm, value) {
    if (!vm.initialized) {
      vm.initialValue = value;
    }
    var validateNow = shouldValidate(vm, value);
    vm._needsValidation = false;
    vm.value = value;
    vm._ignoreImmediate = true;
    if (!validateNow) {
      return;
    }
    var validate = function () {
      if (vm.immediate || vm.flags.validated) {
        return triggerThreadSafeValidation(vm);
      }
      vm.validateSilent();
    };
    if (vm.initialized) {
      validate();
      return;
    }
    vm.$once('hook:mounted', function () {
      return validate();
    });
  }
  function computeModeSetting(ctx) {
    var compute = isCallable(ctx.mode) ? ctx.mode : modes[ctx.mode];
    return compute(ctx);
  }
  function triggerThreadSafeValidation(vm) {
    var pendingPromise = vm.validateSilent();
    // avoids race conditions between successive validations.
    vm._pendingValidation = pendingPromise;
    return pendingPromise.then(function (result) {
      if (pendingPromise === vm._pendingValidation) {
        vm.applyResult(result);
        vm._pendingValidation = undefined;
      }
      return result;
    });
  }
  // Creates the common handlers for a validatable context.
  function createCommonHandlers(vm) {
    if (!vm.$veeOnInput) {
      vm.$veeOnInput = function (e) {
        vm.syncValue(e); // track and keep the value updated.
        vm.setFlags({
          dirty: true,
          pristine: false
        });
      };
    }
    var onInput = vm.$veeOnInput;
    if (!vm.$veeOnBlur) {
      vm.$veeOnBlur = function () {
        vm.setFlags({
          touched: true,
          untouched: false
        });
      };
    }
    // Blur event listener.
    var onBlur = vm.$veeOnBlur;
    var onValidate = vm.$veeHandler;
    var mode = computeModeSetting(vm);
    // Handle debounce changes.
    if (!onValidate || vm.$veeDebounce !== vm.debounce) {
      onValidate = debounce(function () {
        vm.$nextTick(function () {
          if (!vm._pendingReset) {
            triggerThreadSafeValidation(vm);
          }
          vm._pendingReset = false;
        });
      }, mode.debounce || vm.debounce);
      // Cache the handler so we don't create it each time.
      vm.$veeHandler = onValidate;
      // cache the debounce value so we detect if it was changed.
      vm.$veeDebounce = vm.debounce;
    }
    return {
      onInput: onInput,
      onBlur: onBlur,
      onValidate: onValidate
    };
  }
  // Adds all plugin listeners to the vnode.
  function addListeners(vm, node) {
    var value = findValue(node);
    // cache the input eventName.
    vm._inputEventName = vm._inputEventName || getInputEventName(node, findModel(node));
    onRenderUpdate(vm, value === null || value === void 0 ? void 0 : value.value);
    var _a = createCommonHandlers(vm),
      onInput = _a.onInput,
      onBlur = _a.onBlur,
      onValidate = _a.onValidate;
    addVNodeListener(node, vm._inputEventName, onInput);
    addVNodeListener(node, 'blur', onBlur);
    // add the validation listeners.
    vm.normalizedEvents.forEach(function (evt) {
      addVNodeListener(node, evt, onValidate);
    });
    vm.initialized = true;
  }
  var PROVIDER_COUNTER = 0;
  function data$1() {
    var errors = [];
    var fieldName = '';
    var defaultValues = {
      errors: errors,
      value: undefined,
      initialized: false,
      initialValue: undefined,
      flags: createFlags(),
      failedRules: {},
      isActive: true,
      fieldName: fieldName,
      id: ''
    };
    return defaultValues;
  }
  var ValidationProvider = Vue__default['default'].extend({
    name: 'ValidationProvider',
    inject: {
      $_veeObserver: {
        from: '$_veeObserver',
        default: function () {
          if (!this.$vnode.context.$_veeObserver) {
            this.$vnode.context.$_veeObserver = createObserver();
          }
          return this.$vnode.context.$_veeObserver;
        }
      }
    },
    props: {
      vid: {
        type: String,
        default: ''
      },
      name: {
        type: String,
        default: null
      },
      mode: {
        type: [String, Function],
        default: function () {
          return getConfig().mode;
        }
      },
      rules: {
        type: [Object, String],
        default: null
      },
      immediate: {
        type: Boolean,
        default: false
      },
      bails: {
        type: Boolean,
        default: function () {
          return getConfig().bails;
        }
      },
      skipIfEmpty: {
        type: Boolean,
        default: function () {
          return getConfig().skipOptional;
        }
      },
      debounce: {
        type: Number,
        default: 0
      },
      tag: {
        type: String,
        default: 'span'
      },
      slim: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      customMessages: {
        type: Object,
        default: function () {
          return {};
        }
      },
      detectInput: {
        type: Boolean,
        default: true
      }
    },
    watch: {
      rules: {
        deep: true,
        handler: function (val, oldVal) {
          this._needsValidation = !fastDeepEqual(val, oldVal);
        }
      }
    },
    data: data$1,
    computed: {
      fieldDeps: function () {
        var _this = this;
        return Object.keys(this.normalizedRules).reduce(function (acc, rule) {
          var deps = extractLocators(_this.normalizedRules[rule]).map(function (dep) {
            return isLocator(dep) ? dep.__locatorRef : dep.slice(1);
          });
          acc.push.apply(acc, deps);
          deps.forEach(function (depName) {
            watchCrossFieldDep(_this, depName);
          });
          return acc;
        }, []);
      },
      normalizedEvents: function () {
        var _this = this;
        var on = computeModeSetting(this).on;
        return (on || []).map(function (e) {
          if (e === 'input') {
            return _this._inputEventName;
          }
          return e;
        });
      },
      isRequired: function () {
        var rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);
        var isRequired = Object.keys(rules).some(RuleContainer.isRequireRule);
        this.flags.required = !!isRequired;
        return isRequired;
      },
      classes: function () {
        var names = getConfig().classes;
        return computeClassObj(names, this.flags);
      },
      normalizedRules: function () {
        return normalizeRules(this.rules);
      }
    },
    mounted: function () {
      var _this = this;
      var onLocaleChanged = function () {
        if (!_this.flags.validated) {
          return;
        }
        var regenerateMap = _this._regenerateMap;
        if (regenerateMap) {
          var errors_1 = [];
          var failedRules_1 = {};
          Object.keys(regenerateMap).forEach(function (rule) {
            var msg = regenerateMap[rule]();
            errors_1.push(msg);
            failedRules_1[rule] = msg;
          });
          _this.applyResult({
            errors: errors_1,
            failedRules: failedRules_1,
            regenerateMap: regenerateMap
          });
          return;
        }
        _this.validate();
      };
      EVENT_BUS.$on('change:locale', onLocaleChanged);
      this.$on('hook:beforeDestroy', function () {
        EVENT_BUS.$off('change:locale', onLocaleChanged);
      });
    },
    render: function (h) {
      var _this = this;
      this.registerField();
      var ctx = createValidationCtx(this);
      var children = normalizeChildren(this, ctx);
      // Automatic v-model detection
      if (this.detectInput) {
        var inputs = findInputNodes(children);
        if (inputs.length) {
          inputs.forEach(function (input, idx) {
            var _a, _b, _c, _d, _e, _f;
            // If the elements are not checkboxes and there are more input nodes
            if (!includes(['checkbox', 'radio'], (_b = (_a = input.data) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.type) && idx > 0) {
              return;
            }
            var resolved = getConfig().useConstraintAttrs ? resolveRules(input) : {};
            if (!fastDeepEqual(_this._resolvedRules, resolved)) {
              _this._needsValidation = true;
            }
            if (isHTMLNode(input)) {
              _this.fieldName = ((_d = (_c = input.data) === null || _c === void 0 ? void 0 : _c.attrs) === null || _d === void 0 ? void 0 : _d.name) || ((_f = (_e = input.data) === null || _e === void 0 ? void 0 : _e.attrs) === null || _f === void 0 ? void 0 : _f.id);
            }
            _this._resolvedRules = resolved;
            addListeners(_this, input);
          });
        }
      }
      return this.slim && children.length <= 1 ? children[0] : h(this.tag, children);
    },
    beforeDestroy: function () {
      // cleanup reference.
      this.$_veeObserver.unobserve(this.id);
    },
    activated: function () {
      this.isActive = true;
    },
    deactivated: function () {
      this.isActive = false;
    },
    methods: {
      setFlags: function (flags) {
        var _this = this;
        Object.keys(flags).forEach(function (flag) {
          _this.flags[flag] = flags[flag];
        });
      },
      syncValue: function (v) {
        var value = normalizeEventValue(v);
        this.value = value;
        this.flags.changed = !fastDeepEqual(this.initialValue, value);
      },
      reset: function () {
        var _this = this;
        this.errors = [];
        this.initialValue = this.value;
        var flags = createFlags();
        flags.required = this.isRequired;
        this.setFlags(flags);
        this.failedRules = {};
        this.validateSilent();
        this._pendingValidation = undefined;
        this._pendingReset = true;
        setTimeout(function () {
          _this._pendingReset = false;
        }, this.debounce);
      },
      validate: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
            if (args.length > 0) {
              this.syncValue(args[0]);
            }
            return [2 /*return*/, triggerThreadSafeValidation(this)];
          });
        });
      },
      validateSilent: function () {
        return __awaiter(this, void 0, void 0, function () {
          var rules, result;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.setFlags({
                  pending: true
                });
                rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);
                Object.defineProperty(rules, '_$$isNormalized', {
                  value: true,
                  writable: false,
                  enumerable: false,
                  configurable: false
                });
                return [4 /*yield*/, validate(this.value, rules, __assign(__assign({
                  name: this.name || this.fieldName
                }, createLookup(this)), {
                  bails: this.bails,
                  skipIfEmpty: this.skipIfEmpty,
                  isInitial: !this.initialized,
                  customMessages: this.customMessages
                }))];
              case 1:
                result = _a.sent();
                this.setFlags({
                  pending: false,
                  valid: result.valid,
                  invalid: !result.valid
                });
                if (result.required !== undefined) {
                  this.setFlags({
                    required: result.required
                  });
                }
                return [2 /*return*/, result];
            }
          });
        });
      },
      setErrors: function (errors) {
        this.applyResult({
          errors: errors,
          failedRules: {}
        });
      },
      applyResult: function (_a) {
        var errors = _a.errors,
          failedRules = _a.failedRules,
          regenerateMap = _a.regenerateMap;
        this.errors = errors;
        this._regenerateMap = regenerateMap;
        this.failedRules = __assign({}, failedRules || {});
        this.setFlags({
          valid: !errors.length,
          passed: !errors.length,
          invalid: !!errors.length,
          failed: !!errors.length,
          validated: true,
          changed: !fastDeepEqual(this.value, this.initialValue)
        });
      },
      registerField: function () {
        updateRenderingContextRefs(this);
      },
      checkComputesRequiredState: function () {
        var rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);
        var isRequired = Object.keys(rules).some(RuleContainer.isRequireRule);
        return isRequired;
      }
    }
  });
  function computeClassObj(names, flags) {
    var acc = {};
    var keys = Object.keys(flags);
    var length = keys.length;
    var _loop_1 = function (i) {
      var flag = keys[i];
      var className = names && names[flag] || flag;
      var value = flags[flag];
      if (isNullOrUndefined(value)) {
        return "continue";
      }
      if ((flag === 'valid' || flag === 'invalid') && !flags.validated) {
        return "continue";
      }
      if (typeof className === 'string') {
        acc[className] = value;
      } else if (Array.isArray(className)) {
        className.forEach(function (cls) {
          acc[cls] = value;
        });
      }
    };
    for (var i = 0; i < length; i++) {
      _loop_1(i);
    }
    return acc;
  }
  function createLookup(vm) {
    var providers = vm.$_veeObserver.refs;
    var reduced = {
      names: {},
      values: {}
    };
    return vm.fieldDeps.reduce(function (acc, depName) {
      if (!providers[depName]) {
        return acc;
      }
      acc.values[depName] = providers[depName].value;
      acc.names[depName] = providers[depName].name;
      return acc;
    }, reduced);
  }
  function extractId(vm) {
    if (vm.vid) {
      return vm.vid;
    }
    if (vm.name) {
      return vm.name;
    }
    if (vm.id) {
      return vm.id;
    }
    if (vm.fieldName) {
      return vm.fieldName;
    }
    PROVIDER_COUNTER++;
    return "_vee_" + PROVIDER_COUNTER;
  }
  function updateRenderingContextRefs(vm) {
    var providedId = extractId(vm);
    var id = vm.id;
    // Nothing has changed.
    if (!vm.isActive || id === providedId && vm.$_veeObserver.refs[id]) {
      return;
    }
    // vid was changed.
    if (id !== providedId && vm.$_veeObserver.refs[id] === vm) {
      vm.$_veeObserver.unobserve(id);
    }
    vm.id = providedId;
    vm.$_veeObserver.observe(vm);
  }
  function createObserver() {
    return {
      refs: {},
      observe: function (vm) {
        this.refs[vm.id] = vm;
      },
      unobserve: function (id) {
        delete this.refs[id];
      }
    };
  }
  function watchCrossFieldDep(ctx, depName, withHooks) {
    if (withHooks === void 0) {
      withHooks = true;
    }
    var providers = ctx.$_veeObserver.refs;
    if (!ctx._veeWatchers) {
      ctx._veeWatchers = {};
    }
    if (!providers[depName] && withHooks) {
      return ctx.$once('hook:mounted', function () {
        watchCrossFieldDep(ctx, depName, false);
      });
    }
    if (!isCallable(ctx._veeWatchers[depName]) && providers[depName]) {
      ctx._veeWatchers[depName] = providers[depName].$watch('value', function () {
        var isComputesRequired = ctx.checkComputesRequiredState();
        if (ctx.flags.validated) {
          ctx._needsValidation = true;
          ctx.validate();
        }
        // Validate dependent field silently if it has rules with computesRequired
        if (isComputesRequired && !ctx.flags.validated) {
          ctx.validateSilent();
        }
      });
    }
  }
  var FLAGS_STRATEGIES = [['pristine', 'every'], ['dirty', 'some'], ['touched', 'some'], ['untouched', 'every'], ['valid', 'every'], ['invalid', 'some'], ['pending', 'some'], ['validated', 'every'], ['changed', 'some'], ['passed', 'every'], ['failed', 'some']];
  var OBSERVER_COUNTER = 0;
  function data() {
    var refs = {};
    var errors = {};
    var flags = createObserverFlags();
    var fields = {};
    // FIXME: Not sure of this one can be typed, circular type reference.
    var observers = [];
    return {
      id: '',
      refs: refs,
      observers: observers,
      errors: errors,
      flags: flags,
      fields: fields
    };
  }
  function provideSelf() {
    return {
      $_veeObserver: this
    };
  }
  var ValidationObserver = Vue__default['default'].extend({
    name: 'ValidationObserver',
    provide: provideSelf,
    inject: {
      $_veeObserver: {
        from: '$_veeObserver',
        default: function () {
          if (!this.$vnode.context.$_veeObserver) {
            return null;
          }
          return this.$vnode.context.$_veeObserver;
        }
      }
    },
    props: {
      tag: {
        type: String,
        default: 'span'
      },
      vid: {
        type: String,
        default: function () {
          return "obs_" + OBSERVER_COUNTER++;
        }
      },
      slim: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    data: data,
    created: function () {
      var _this = this;
      this.id = this.vid;
      register(this);
      var onChange = debounce(function (_a) {
        var errors = _a.errors,
          flags = _a.flags,
          fields = _a.fields;
        _this.errors = errors;
        _this.flags = flags;
        _this.fields = fields;
      }, 16);
      this.$watch(computeObserverState, onChange);
    },
    activated: function () {
      register(this);
    },
    deactivated: function () {
      unregister(this);
    },
    beforeDestroy: function () {
      unregister(this);
    },
    render: function (h) {
      var children = normalizeChildren(this, prepareSlotProps(this));
      return this.slim && children.length <= 1 ? children[0] : h(this.tag, {
        on: this.$listeners
      }, children);
    },
    methods: {
      observe: function (subscriber, kind) {
        var _a;
        if (kind === void 0) {
          kind = 'provider';
        }
        if (kind === 'observer') {
          this.observers.push(subscriber);
          return;
        }
        this.refs = __assign(__assign({}, this.refs), (_a = {}, _a[subscriber.id] = subscriber, _a));
      },
      unobserve: function (id, kind) {
        if (kind === void 0) {
          kind = 'provider';
        }
        if (kind === 'provider') {
          var provider = this.refs[id];
          if (!provider) {
            return;
          }
          this.$delete(this.refs, id);
          return;
        }
        var idx = findIndex(this.observers, function (o) {
          return o.id === id;
        });
        if (idx !== -1) {
          this.observers.splice(idx, 1);
        }
      },
      validateWithInfo: function (_a) {
        var _b = (_a === void 0 ? {} : _a).silent,
          silent = _b === void 0 ? false : _b;
        return __awaiter(this, void 0, void 0, function () {
          var results, isValid, _c, errors, flags, fields;
          return __generator(this, function (_d) {
            switch (_d.label) {
              case 0:
                return [4 /*yield*/, Promise.all(__spreadArrays(values(this.refs).filter(function (r) {
                  return !r.disabled;
                }).map(function (ref) {
                  return ref[silent ? 'validateSilent' : 'validate']().then(function (r) {
                    return r.valid;
                  });
                }), this.observers.filter(function (o) {
                  return !o.disabled;
                }).map(function (obs) {
                  return obs.validate({
                    silent: silent
                  });
                })))];
              case 1:
                results = _d.sent();
                isValid = results.every(function (r) {
                  return r;
                });
                _c = computeObserverState.call(this), errors = _c.errors, flags = _c.flags, fields = _c.fields;
                this.errors = errors;
                this.flags = flags;
                this.fields = fields;
                return [2 /*return*/, {
                  errors: errors,
                  flags: flags,
                  fields: fields,
                  isValid: isValid
                }];
            }
          });
        });
      },
      validate: function (_a) {
        var _b = (_a === void 0 ? {} : _a).silent,
          silent = _b === void 0 ? false : _b;
        return __awaiter(this, void 0, void 0, function () {
          var isValid;
          return __generator(this, function (_c) {
            switch (_c.label) {
              case 0:
                return [4 /*yield*/, this.validateWithInfo({
                  silent: silent
                })];
              case 1:
                isValid = _c.sent().isValid;
                return [2 /*return*/, isValid];
            }
          });
        });
      },
      handleSubmit: function (cb) {
        return __awaiter(this, void 0, void 0, function () {
          var isValid;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4 /*yield*/, this.validate()];
              case 1:
                isValid = _a.sent();
                if (!isValid || !cb) {
                  return [2 /*return*/];
                }

                return [2 /*return*/, cb()];
            }
          });
        });
      },
      reset: function () {
        return __spreadArrays(values(this.refs), this.observers).forEach(function (ref) {
          return ref.reset();
        });
      },
      setErrors: function (errors) {
        var _this = this;
        Object.keys(errors).forEach(function (key) {
          var provider = _this.refs[key];
          if (!provider) return;
          var errorArr = errors[key] || [];
          errorArr = typeof errorArr === 'string' ? [errorArr] : errorArr;
          provider.setErrors(errorArr);
        });
        this.observers.forEach(function (observer) {
          observer.setErrors(errors);
        });
      }
    }
  });
  function unregister(vm) {
    if (vm.$_veeObserver) {
      vm.$_veeObserver.unobserve(vm.id, 'observer');
    }
  }
  function register(vm) {
    if (vm.$_veeObserver) {
      vm.$_veeObserver.observe(vm, 'observer');
    }
  }
  function prepareSlotProps(vm) {
    return __assign(__assign({}, vm.flags), {
      errors: vm.errors,
      fields: vm.fields,
      validate: vm.validate,
      validateWithInfo: vm.validateWithInfo,
      passes: vm.handleSubmit,
      handleSubmit: vm.handleSubmit,
      reset: vm.reset
    });
  }
  // Creates a modified version of validation flags
  function createObserverFlags() {
    return __assign(__assign({}, createFlags()), {
      valid: true,
      invalid: false
    });
  }
  function computeObserverState() {
    var vms = __spreadArrays(values(this.refs), this.observers.filter(function (o) {
      return !o.disabled;
    }));
    var errors = {};
    var flags = createObserverFlags();
    var fields = {};
    var length = vms.length;
    for (var i = 0; i < length; i++) {
      var vm = vms[i];
      // validation provider
      if (Array.isArray(vm.errors)) {
        errors[vm.id] = vm.errors;
        fields[vm.id] = __assign({
          id: vm.id,
          name: vm.name,
          failedRules: vm.failedRules
        }, vm.flags);
        continue;
      }
      // Nested observer, merge errors and fields
      errors = __assign(__assign({}, errors), vm.errors);
      fields = __assign(__assign({}, fields), vm.fields);
    }
    FLAGS_STRATEGIES.forEach(function (_a) {
      var flag = _a[0],
        method = _a[1];
      flags[flag] = vms[method](function (vm) {
        return vm.flags[flag];
      });
    });
    return {
      errors: errors,
      flags: flags,
      fields: fields
    };
  }
  function withValidation(component, mapProps) {
    var _a;
    if (mapProps === void 0) {
      mapProps = identity;
    }
    var options = 'options' in component ? component.options : component;
    var providerOpts = ValidationProvider.options;
    var hoc = {
      name: (options.name || 'AnonymousHoc') + "WithValidation",
      props: __assign({}, providerOpts.props),
      data: providerOpts.data,
      computed: __assign({}, providerOpts.computed),
      methods: __assign({}, providerOpts.methods),
      beforeDestroy: providerOpts.beforeDestroy,
      inject: providerOpts.inject
    };
    var eventName = ((_a = options === null || options === void 0 ? void 0 : options.model) === null || _a === void 0 ? void 0 : _a.event) || 'input';
    hoc.render = function (h) {
      var _a;
      this.registerField();
      var vctx = createValidationCtx(this);
      var listeners = __assign({}, this.$listeners);
      var model = findModel(this.$vnode);
      this._inputEventName = this._inputEventName || getInputEventName(this.$vnode, model);
      var value = findValue(this.$vnode);
      onRenderUpdate(this, value === null || value === void 0 ? void 0 : value.value);
      var _b = createCommonHandlers(this),
        onInput = _b.onInput,
        onBlur = _b.onBlur,
        onValidate = _b.onValidate;
      mergeVNodeListeners(listeners, eventName, onInput);
      mergeVNodeListeners(listeners, 'blur', onBlur);
      this.normalizedEvents.forEach(function (evt) {
        mergeVNodeListeners(listeners, evt, onValidate);
      });
      // Props are any attrs not associated with ValidationProvider Plus the model prop.
      // WARNING: Accidental prop overwrite will probably happen.
      var prop = (findModelConfig(this.$vnode) || {
        prop: 'value'
      }).prop;
      var props = __assign(__assign(__assign({}, this.$attrs), (_a = {}, _a[prop] = model === null || model === void 0 ? void 0 : model.value, _a)), mapProps(vctx));
      return h(options, {
        attrs: this.$attrs,
        props: props,
        on: listeners,
        scopedSlots: this.$scopedSlots
      }, normalizeSlots(this.$slots, this.$vnode.context));
    };
    return hoc;
  }
  var version = '3.4.14';
  exports.ValidationObserver = ValidationObserver;
  exports.ValidationProvider = ValidationProvider;
  exports.configure = configure;
  exports.extend = extend;
  exports.localeChanged = localeChanged;
  exports.localize = localize;
  exports.normalizeRules = normalizeRules;
  exports.setInteractionMode = setInteractionMode;
  exports.validate = validate;
  exports.version = version;
  exports.withValidation = withValidation;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("vuex");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("vue-no-ssr");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ addStylesServer; });

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesServer.js


function addStylesServer (parentId, list, isProduction, context) {
  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
    context = __VUE_SSR_CONTEXT__
  }
  if (context) {
    if (!context.hasOwnProperty('styles')) {
      Object.defineProperty(context, 'styles', {
        enumerable: true,
        get: function() {
          return renderStyles(context._styles)
        }
      })
      // expose renderStyles for vue-server-renderer (vuejs/#6353)
      context._renderStyles = renderStyles
    }

    var styles = context._styles || (context._styles = {})
    list = listToStyles(parentId, list)
    if (isProduction) {
      addStyleProd(styles, list)
    } else {
      addStyleDev(styles, list)
    }
  }
}

// In production, render as few style tags as possible.
// (mostly because IE9 has a limit on number of style tags)
function addStyleProd (styles, list) {
  for (var i = 0; i < list.length; i++) {
    var parts = list[i].parts
    for (var j = 0; j < parts.length; j++) {
      var part = parts[j]
      // group style tags by media types.
      var id = part.media || 'default'
      var style = styles[id]
      if (style) {
        if (style.ids.indexOf(part.id) < 0) {
          style.ids.push(part.id)
          style.css += '\n' + part.css
        }
      } else {
        styles[id] = {
          ids: [part.id],
          css: part.css,
          media: part.media
        }
      }
    }
  }
}

// In dev we use individual style tag for each module for hot-reload
// and source maps.
function addStyleDev (styles, list) {
  for (var i = 0; i < list.length; i++) {
    var parts = list[i].parts
    for (var j = 0; j < parts.length; j++) {
      var part = parts[j]
      styles[part.id] = {
        ids: [part.id],
        css: part.css,
        media: part.media
      }
    }
  }
}

function renderStyles (styles) {
  var css = ''
  for (var key in styles) {
    var style = styles[key]
    css += '<style data-vue-ssr-id="' + style.ids.join(' ') + '"' +
        (style.media ? ( ' media="' + style.media + '"' ) : '') + '>' +
        style.css + '</style>'
  }
  return css
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export alpha */
/* unused harmony export alpha_dash */
/* unused harmony export alpha_num */
/* unused harmony export alpha_spaces */
/* unused harmony export between */
/* unused harmony export confirmed */
/* unused harmony export digits */
/* unused harmony export dimensions */
/* unused harmony export double */
/* unused harmony export email */
/* unused harmony export excluded */
/* unused harmony export ext */
/* unused harmony export image */
/* unused harmony export integer */
/* unused harmony export is */
/* unused harmony export is_not */
/* unused harmony export length */
/* unused harmony export max */
/* unused harmony export max_value */
/* unused harmony export mimes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return min; });
/* unused harmony export min_value */
/* unused harmony export numeric */
/* unused harmony export oneOf */
/* unused harmony export regex */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return required; });
/* unused harmony export required_if */
/* unused harmony export size */
/**
  * vee-validate v3.4.14
  * (c) 2021 Abdelrahman Awad
  * @license MIT
  */
/**
 * Some Alpha Regex helpers.
 * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js
 */
/* eslint-disable no-misleading-character-class */
var alpha$1 = {
  en: /^[A-Z]*$/i,
  cs: /^[A-Z]*$/i,
  da: /^[A-Z]*$/i,
  de: /^[A-Z]*$/i,
  es: /^[A-Z]*$/i,
  fa: /^[]*$/,
  fr: /^[A-Z]*$/i,
  it: /^[A-Z\xC0-\xFF]*$/i,
  lt: /^[A-Z]*$/i,
  nl: /^[A-Z]*$/i,
  hu: /^[A-Z]*$/i,
  pl: /^[A-Z]*$/i,
  pt: /^[A-Z]*$/i,
  ro: /^[A-Z]*$/i,
  ru: /^[-]*$/i,
  sk: /^[A-Z]*$/i,
  sr: /^[A-Z]*$/i,
  sv: /^[A-Z]*$/i,
  tr: /^[A-Z]*$/i,
  uk: /^[-]*$/i,
  ar: /^[]*$/,
  az: /^[A-Z]*$/i,
  el: /^[-]*$/i,
  ja: /^[A-Z\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\u4E00-\u9FAF]*$/i,
  he: /^[A-Z\u05D0-\u05EA']*$/i
};
var alphaSpaces = {
  en: /^[A-Z\s]*$/i,
  cs: /^[A-Z\s]*$/i,
  da: /^[A-Z\s]*$/i,
  de: /^[A-Z\s]*$/i,
  es: /^[A-Z\s]*$/i,
  fa: /^[]*$/,
  fr: /^[A-Z\s]*$/i,
  it: /^[A-Z\xC0-\xFF\s]*$/i,
  lt: /^[A-Z\s]*$/i,
  nl: /^[A-Z\s]*$/i,
  hu: /^[A-Z\s]*$/i,
  pl: /^[A-Z\s]*$/i,
  pt: /^[A-Z\s]*$/i,
  ro: /^[A-Z\s]*$/i,
  ru: /^[-\s]*$/i,
  sk: /^[A-Z\s]*$/i,
  sr: /^[A-Z\s]*$/i,
  sv: /^[A-Z\s]*$/i,
  tr: /^[A-Z\s]*$/i,
  uk: /^[-\s]*$/i,
  ar: /^[\s]*$/,
  az: /^[A-Z\s]*$/i,
  el: /^[-\s]*$/i,
  ja: /^[A-Z\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\u4E00-\u9FAF\s]*$/i,
  he: /^[A-Z\u05D0-\u05EA'\s]*$/i
};
var alphanumeric = {
  en: /^[0-9A-Z]*$/i,
  cs: /^[0-9A-Z]*$/i,
  da: /^[0-9A-Z]$/i,
  de: /^[0-9A-Z]*$/i,
  es: /^[0-9A-Z]*$/i,
  fa: /^[]*$/,
  fr: /^[0-9A-Z]*$/i,
  it: /^[0-9A-Z\xC0-\xFF]*$/i,
  lt: /^[0-9A-Z]*$/i,
  hu: /^[0-9A-Z]*$/i,
  nl: /^[0-9A-Z]*$/i,
  pl: /^[0-9A-Z]*$/i,
  pt: /^[0-9A-Z]*$/i,
  ro: /^[0-9A-Z]*$/i,
  ru: /^[0-9-]*$/i,
  sk: /^[0-9A-Z]*$/i,
  sr: /^[0-9A-Z]*$/i,
  sv: /^[0-9A-Z]*$/i,
  tr: /^[0-9A-Z]*$/i,
  uk: /^[0-9-]*$/i,
  ar: /^[0-9]*$/,
  az: /^[0-9A-Z]*$/i,
  el: /^[0-9-]*$/i,
  ja: /^[0-9A-Z\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\u4E00-\u9FAF]*$/i,
  he: /^[0-9A-Z\u05D0-\u05EA']*$/i
};
var alphaDash = {
  en: /^[0-9A-Z_-]*$/i,
  cs: /^[0-9A-Z_-]*$/i,
  da: /^[0-9A-Z_-]*$/i,
  de: /^[0-9A-Z_-]*$/i,
  es: /^[0-9A-Z_-]*$/i,
  fa: /^[]*$/,
  fr: /^[0-9A-Z_-]*$/i,
  it: /^[0-9A-Z\xC0-\xFF_-]*$/i,
  lt: /^[0-9A-Z_-]*$/i,
  nl: /^[0-9A-Z_-]*$/i,
  hu: /^[0-9A-Z_-]*$/i,
  pl: /^[0-9A-Z_-]*$/i,
  pt: /^[0-9A-Z_-]*$/i,
  ro: /^[0-9A-Z_-]*$/i,
  ru: /^[0-9-_-]*$/i,
  sk: /^[0-9A-Z_-]*$/i,
  sr: /^[0-9A-Z_-]*$/i,
  sv: /^[0-9A-Z_-]*$/i,
  tr: /^[0-9A-Z_-]*$/i,
  uk: /^[0-9-_-]*$/i,
  ar: /^[0-9_-]*$/,
  az: /^[0-9A-Z_-]*$/i,
  el: /^[0-9-_-]*$/i,
  ja: /^[0-9A-Z\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\u4E00-\u9FAF_-]*$/i,
  he: /^[0-9A-Z\u05D0-\u05EA'_-]*$/i
};
var validate$r = function (value, _a) {
  var _b = (_a === void 0 ? {} : _a).locale,
    locale = _b === void 0 ? '' : _b;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$r(val, {
        locale: locale
      });
    });
  }
  // Match at least one locale.
  if (!locale) {
    return Object.keys(alpha$1).some(function (loc) {
      return alpha$1[loc].test(value);
    });
  }
  return (alpha$1[locale] || alpha$1.en).test(value);
};
var params$k = [{
  name: 'locale'
}];
var alpha = {
  validate: validate$r,
  params: params$k
};
var validate$q = function (value, _a) {
  var _b = (_a === void 0 ? {} : _a).locale,
    locale = _b === void 0 ? '' : _b;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$q(val, {
        locale: locale
      });
    });
  }
  // Match at least one locale.
  if (!locale) {
    return Object.keys(alphaDash).some(function (loc) {
      return alphaDash[loc].test(value);
    });
  }
  return (alphaDash[locale] || alphaDash.en).test(value);
};
var params$j = [{
  name: 'locale'
}];
var alpha_dash = {
  validate: validate$q,
  params: params$j
};
var validate$p = function (value, _a) {
  var _b = (_a === void 0 ? {} : _a).locale,
    locale = _b === void 0 ? '' : _b;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$p(val, {
        locale: locale
      });
    });
  }
  // Match at least one locale.
  if (!locale) {
    return Object.keys(alphanumeric).some(function (loc) {
      return alphanumeric[loc].test(value);
    });
  }
  return (alphanumeric[locale] || alphanumeric.en).test(value);
};
var params$i = [{
  name: 'locale'
}];
var alpha_num = {
  validate: validate$p,
  params: params$i
};
var validate$o = function (value, _a) {
  var _b = (_a === void 0 ? {} : _a).locale,
    locale = _b === void 0 ? '' : _b;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$o(val, {
        locale: locale
      });
    });
  }
  // Match at least one locale.
  if (!locale) {
    return Object.keys(alphaSpaces).some(function (loc) {
      return alphaSpaces[loc].test(value);
    });
  }
  return (alphaSpaces[locale] || alphaSpaces.en).test(value);
};
var params$h = [{
  name: 'locale'
}];
var alpha_spaces = {
  validate: validate$o,
  params: params$h
};
var validate$n = function (value, _a) {
  var _b = _a === void 0 ? {} : _a,
    min = _b.min,
    max = _b.max;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return !!validate$n(val, {
        min: min,
        max: max
      });
    });
  }
  return Number(min) <= value && Number(max) >= value;
};
var params$g = [{
  name: 'min'
}, {
  name: 'max'
}];
var between = {
  validate: validate$n,
  params: params$g
};
var validate$m = function (value, _a) {
  var target = _a.target;
  return String(value) === String(target);
};
var params$f = [{
  name: 'target',
  isTarget: true
}];
var confirmed = {
  validate: validate$m,
  params: params$f
};
var validate$l = function (value, _a) {
  var length = _a.length;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$l(val, {
        length: length
      });
    });
  }
  var strVal = String(value);
  return /^[0-9]*$/.test(strVal) && strVal.length === length;
};
var params$e = [{
  name: 'length',
  cast: function (value) {
    return Number(value);
  }
}];
var digits = {
  validate: validate$l,
  params: params$e
};
var validateImage = function (file, width, height) {
  var URL = window.URL || window.webkitURL;
  return new Promise(function (resolve) {
    var image = new Image();
    image.onerror = function () {
      return resolve(false);
    };
    image.onload = function () {
      return resolve(image.width === width && image.height === height);
    };
    image.src = URL.createObjectURL(file);
  });
};
var validate$k = function (files, _a) {
  var width = _a.width,
    height = _a.height;
  var list = [];
  files = Array.isArray(files) ? files : [files];
  for (var i = 0; i < files.length; i++) {
    // if file is not an image, reject.
    if (!/\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
      return Promise.resolve(false);
    }
    list.push(files[i]);
  }
  return Promise.all(list.map(function (file) {
    return validateImage(file, width, height);
  })).then(function (values) {
    return values.every(function (v) {
      return v;
    });
  });
};
var params$d = [{
  name: 'width',
  cast: function (value) {
    return Number(value);
  }
}, {
  name: 'height',
  cast: function (value) {
    return Number(value);
  }
}];
var dimensions = {
  validate: validate$k,
  params: params$d
};
var validate$j = function (value, _a) {
  var multiple = (_a === void 0 ? {} : _a).multiple;
  // eslint-disable-next-line
  var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  if (multiple && !Array.isArray(value)) {
    value = String(value).split(',').map(function (emailStr) {
      return emailStr.trim();
    });
  }
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return re.test(String(val));
    });
  }
  return re.test(String(value));
};
var params$c = [{
  name: 'multiple',
  default: false
}];
var email = {
  validate: validate$j,
  params: params$c
};
function isNullOrUndefined(value) {
  return value === null || value === undefined;
}
function isEmptyArray(arr) {
  return Array.isArray(arr) && arr.length === 0;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isCallable(fn) {
  return typeof fn === 'function';
}
function includes(collection, item) {
  return collection.indexOf(item) !== -1;
}
/**
 * Converts an array-like object to array, provides a simple polyfill for Array.from
 */
function toArray(arrayLike) {
  if (isCallable(Array.from)) {
    return Array.from(arrayLike);
  }
  /* istanbul ignore next */
  return _copyArray(arrayLike);
}
/* istanbul ignore next */
function _copyArray(arrayLike) {
  var array = [];
  var length = arrayLike.length;
  for (var i = 0; i < length; i++) {
    array.push(arrayLike[i]);
  }
  return array;
}
var validate$i = function (value, options) {
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$i(val, options);
    });
  }
  return toArray(options).some(function (item) {
    // eslint-disable-next-line
    return item == value;
  });
};
var oneOf = {
  validate: validate$i
};
var validate$h = function (value, args) {
  return !validate$i(value, args);
};
var excluded = {
  validate: validate$h
};
var validate$g = function (files, extensions) {
  var regex = new RegExp(".(" + extensions.join('|') + ")$", 'i');
  if (Array.isArray(files)) {
    return files.every(function (file) {
      return regex.test(file.name);
    });
  }
  return regex.test(files.name);
};
var ext = {
  validate: validate$g
};
var validate$f = function (files) {
  var regex = /\.(jpg|svg|jpeg|png|bmp|gif|webp)$/i;
  if (Array.isArray(files)) {
    return files.every(function (file) {
      return regex.test(file.name);
    });
  }
  return regex.test(files.name);
};
var image = {
  validate: validate$f
};
var validate$e = function (value) {
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return /^-?[0-9]+$/.test(String(val));
    });
  }
  return /^-?[0-9]+$/.test(String(value));
};
var integer = {
  validate: validate$e
};
var validate$d = function (value, _a) {
  var other = _a.other;
  return value === other;
};
var params$b = [{
  name: 'other'
}];
var is = {
  validate: validate$d,
  params: params$b
};
var validate$c = function (value, _a) {
  var other = _a.other;
  return value !== other;
};
var params$a = [{
  name: 'other'
}];
var is_not = {
  validate: validate$c,
  params: params$a
};
var validate$b = function (value, _a) {
  var length = _a.length;
  if (isNullOrUndefined(value)) {
    return false;
  }
  if (typeof value === 'string') {
    value = toArray(value);
  }
  if (typeof value === 'number') {
    value = String(value);
  }
  if (!value.length) {
    value = toArray(value);
  }
  return value.length === length;
};
var params$9 = [{
  name: 'length',
  cast: function (value) {
    return Number(value);
  }
}];
var length = {
  validate: validate$b,
  params: params$9
};
var validate$a = function (value, _a) {
  var length = _a.length;
  if (isNullOrUndefined(value)) {
    return length >= 0;
  }
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$a(val, {
        length: length
      });
    });
  }
  return String(value).length <= length;
};
var params$8 = [{
  name: 'length',
  cast: function (value) {
    return Number(value);
  }
}];
var max = {
  validate: validate$a,
  params: params$8
};
var validate$9 = function (value, _a) {
  var max = _a.max;
  if (isNullOrUndefined(value) || value === '') {
    return false;
  }
  if (Array.isArray(value)) {
    return value.length > 0 && value.every(function (val) {
      return validate$9(val, {
        max: max
      });
    });
  }
  return Number(value) <= max;
};
var params$7 = [{
  name: 'max',
  cast: function (value) {
    return Number(value);
  }
}];
var max_value = {
  validate: validate$9,
  params: params$7
};
var validate$8 = function (files, mimes) {
  var regex = new RegExp(mimes.join('|').replace('*', '.+') + "$", 'i');
  if (Array.isArray(files)) {
    return files.every(function (file) {
      return regex.test(file.type);
    });
  }
  return regex.test(files.type);
};
var mimes = {
  validate: validate$8
};
var validate$7 = function (value, _a) {
  var length = _a.length;
  if (isNullOrUndefined(value)) {
    return false;
  }
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$7(val, {
        length: length
      });
    });
  }
  return String(value).length >= length;
};
var params$6 = [{
  name: 'length',
  cast: function (value) {
    return Number(value);
  }
}];
var min = {
  validate: validate$7,
  params: params$6
};
var validate$6 = function (value, _a) {
  var min = _a.min;
  if (isNullOrUndefined(value) || value === '') {
    return false;
  }
  if (Array.isArray(value)) {
    return value.length > 0 && value.every(function (val) {
      return validate$6(val, {
        min: min
      });
    });
  }
  return Number(value) >= min;
};
var params$5 = [{
  name: 'min',
  cast: function (value) {
    return Number(value);
  }
}];
var min_value = {
  validate: validate$6,
  params: params$5
};
var ar = /^[]+$/;
var en = /^[0-9]+$/;
var validate$5 = function (value) {
  var testValue = function (val) {
    var strValue = String(val);
    return en.test(strValue) || ar.test(strValue);
  };
  if (Array.isArray(value)) {
    return value.every(testValue);
  }
  return testValue(value);
};
var numeric = {
  validate: validate$5
};
var validate$4 = function (value, _a) {
  var regex = _a.regex;
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$4(val, {
        regex: regex
      });
    });
  }
  return regex.test(String(value));
};
var params$4 = [{
  name: 'regex',
  cast: function (value) {
    if (typeof value === 'string') {
      return new RegExp(value);
    }
    return value;
  }
}];
var regex = {
  validate: validate$4,
  params: params$4
};
var validate$3 = function (value, _a) {
  var allowFalse = (_a === void 0 ? {
    allowFalse: true
  } : _a).allowFalse;
  var result = {
    valid: false,
    required: true
  };
  if (isNullOrUndefined(value) || isEmptyArray(value)) {
    return result;
  }
  // incase a field considers `false` as an empty value like checkboxes.
  if (value === false && !allowFalse) {
    return result;
  }
  result.valid = !!String(value).trim().length;
  return result;
};
var computesRequired$1 = true;
var params$3 = [{
  name: 'allowFalse',
  default: true
}];
var required = {
  validate: validate$3,
  params: params$3,
  computesRequired: computesRequired$1
};
var testEmpty = function (value) {
  return isEmptyArray(value) || includes([false, null, undefined], value) || !String(value).trim().length;
};
var validate$2 = function (value, _a) {
  var target = _a.target,
    values = _a.values;
  var required;
  if (values && values.length) {
    if (!Array.isArray(values) && typeof values === 'string') {
      values = [values];
    }
    // eslint-disable-next-line
    required = values.some(function (val) {
      return val == String(target).trim();
    });
  } else {
    required = !testEmpty(target);
  }
  if (!required) {
    return {
      valid: true,
      required: required
    };
  }
  return {
    valid: !testEmpty(value),
    required: required
  };
};
var params$2 = [{
  name: 'target',
  isTarget: true
}, {
  name: 'values'
}];
var computesRequired = true;
var required_if = {
  validate: validate$2,
  params: params$2,
  computesRequired: computesRequired
};
var validate$1 = function (files, _a) {
  var size = _a.size;
  if (isNaN(size)) {
    return false;
  }
  var nSize = size * 1024;
  if (!Array.isArray(files)) {
    return files.size <= nSize;
  }
  for (var i = 0; i < files.length; i++) {
    if (files[i].size > nSize) {
      return false;
    }
  }
  return true;
};
var params$1 = [{
  name: 'size',
  cast: function (value) {
    return Number(value);
  }
}];
var size = {
  validate: validate$1,
  params: params$1
};
var validate = function (value, params) {
  var _a = params || {},
    _b = _a.decimals,
    decimals = _b === void 0 ? 0 : _b,
    _c = _a.separator,
    separator = _c === void 0 ? 'dot' : _c;
  var delimiterRegexPart = separator === 'comma' ? ',?' : '\\.?';
  var decimalRegexPart = decimals === 0 ? '\\d*' : "(\\d{" + decimals + "})?";
  var regex = new RegExp("^-?\\d+" + delimiterRegexPart + decimalRegexPart + "$");
  return Array.isArray(value) ? value.every(function (val) {
    return regex.test(String(val));
  }) : regex.test(String(value));
};
var params = [{
  name: 'decimals',
  default: 0
}, {
  name: 'separator',
  default: 'dot'
}];
var double = {
  validate: validate,
  params: params
};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("vue-client-only");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("vue-router");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(20);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(7).default
module.exports.__inject__ = function (context) {
  add("3d8de15e", content, true, context)
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(22);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(7).default
module.exports.__inject__ = function (context) {
  add("6439d180", content, true, context)
};

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("vue-meta");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("vue-the-mask");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18);
module.exports = __webpack_require__(28);


/***/ }),
/* 18 */
/***/ (function(module, exports) {

global.installComponents = function (component, components) {
  var options = typeof component.exports === 'function'
    ? component.exports.extendOptions
    : component.options

  if (typeof component.exports === 'function') {
    options.components = component.exports.options.components
  }

  options.components = options.components || {}

  for (var i in components) {
    options.components[i] = options.components[i] || components[i]
  }


  if (options.functional) {
    provideFunctionalComponents(component, options.components)
  }
}

var functionalPatchKey = '_functionalComponents'

function provideFunctionalComponents(component, components) {
  if (component.exports[functionalPatchKey]) {
    return
  }
  component.exports[functionalPatchKey] = true

  var render = component.exports.render
  component.exports.render = function (h, vm) {
    return render(h, Object.assign({}, vm, {
      _c: function (n, a, b) {
        return vm._c(components[n] || n, a, b)
      }
    }))
  }
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_5eb69f1c_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_5eb69f1c_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_5eb69f1c_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_5eb69f1c_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_5eb69f1c_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".__nuxt-error-page{padding:1rem;background:#f7f8fb;color:#47494e;text-align:center;display:flex;justify-content:center;align-items:center;flex-direction:column;font-family:sans-serif;font-weight:100!important;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased;position:absolute;top:0;left:0;right:0;bottom:0}.__nuxt-error-page .error{max-width:450px}.__nuxt-error-page .title{font-size:1.5rem;margin-top:15px;color:#47494e;margin-bottom:8px}.__nuxt-error-page .description{color:#7f828b;line-height:21px;margin-bottom:10px}.__nuxt-error-page a{color:#7f828b!important;text-decoration:none}.__nuxt-error-page .logo{position:fixed;left:12px;bottom:12px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_33856d5f_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_33856d5f_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_33856d5f_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_33856d5f_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_33856d5f_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(24);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
__webpack_require__(7).default("2d79f4b2", content, true)

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(16);
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(25);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}html{height:100%}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:\"\";content:none}table{border-collapse:collapse;border-spacing:0}.container{padding:8px 20px}@media screen and (min-width:1024px){.container{padding:8px 135px}}body{background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");background-size:cover;background-repeat:no-repeat;font-family:\"Proxima Nova\"}button{cursor:pointer;-webkit-tap-highlight-color:rgba(255,255,255,0);-webkit-tap-highlight-color:rgba(0,0,0,0)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/mainBg.0f35288.png";

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "state", function() { return state; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mutations", function() { return mutations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getters", function() { return getters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actions", function() { return actions; });
const state = () => ({
  showPopup: false
});
const mutations = {
  open(state) {
    state.showPopup = true;
  },
  close(state) {
    state.showPopup = false;
  }
};
const getters = {
  showPopup: state => {
    return state.showPopup;
  }
};
const actions = {
  toggle({
    commit,
    state
  }, value) {
    if (state.showPopup === true) {
      commit('close');
    } else {
      commit('open');
    }
  },
  close({
    commit,
    state
  }) {
    commit('close');
  }
};

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("core-js/modules/es.regexp.flags.js");

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// NAMESPACE OBJECT: ./.nuxt/components/index.js
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, "VForm", function() { return VForm; });
__webpack_require__.d(components_namespaceObject, "VHeader", function() { return VHeader; });
__webpack_require__.d(components_namespaceObject, "VHero", function() { return VHero; });
__webpack_require__.d(components_namespaceObject, "VPopup", function() { return VPopup; });
__webpack_require__.d(components_namespaceObject, "VRewards", function() { return VRewards; });
__webpack_require__.d(components_namespaceObject, "VSelect", function() { return VSelect; });
__webpack_require__.d(components_namespaceObject, "VTimer", function() { return VTimer; });

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(0);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// EXTERNAL MODULE: external "ufo"
var external_ufo_ = __webpack_require__(1);

// EXTERNAL MODULE: external "node-fetch"
var external_node_fetch_ = __webpack_require__(13);
var external_node_fetch_default = /*#__PURE__*/__webpack_require__.n(external_node_fetch_);

// CONCATENATED MODULE: ./.nuxt/middleware.js
const middleware = {};
/* harmony default export */ var _nuxt_middleware = (middleware);
// CONCATENATED MODULE: ./.nuxt/utils.js



// window.{{globals.loadedCallback}} hook
// Useful for jsdom testing or plugins (https://github.com/tmpvar/jsdom#dealing-with-asynchronous-script-loading)
if (false) {}
function createGetCounter(counterObject, defaultKey = '') {
  return function getCounter(id = defaultKey) {
    if (counterObject[id] === undefined) {
      counterObject[id] = 0;
    }
    return counterObject[id]++;
  };
}
function empty() {}
function globalHandleError(error) {
  if (external_vue_default.a.config.errorHandler) {
    external_vue_default.a.config.errorHandler(error);
  }
}
function interopDefault(promise) {
  return promise.then(m => m.default || m);
}
function hasFetch(vm) {
  return vm.$options && typeof vm.$options.fetch === 'function' && !vm.$options.fetch.length;
}
function purifyData(data) {
  if (true) {
    return data;
  }
  return Object.entries(data).filter(([key, value]) => {
    const valid = !(value instanceof Function) && !(value instanceof Promise);
    if (!valid) {
      console.warn(`${key} is not able to be stringified. This will break in a production environment.`);
    }
    return valid;
  }).reduce((obj, [key, value]) => {
    obj[key] = value;
    return obj;
  }, {});
}
function getChildrenComponentInstancesUsingFetch(vm, instances = []) {
  const children = vm.$children || [];
  for (const child of children) {
    if (child.$fetch) {
      instances.push(child);
      continue; // Don't get the children since it will reload the template
    }

    if (child.$children) {
      getChildrenComponentInstancesUsingFetch(child, instances);
    }
  }
  return instances;
}
function applyAsyncData(Component, asyncData) {
  if (
  // For SSR, we once all this function without second param to just apply asyncData
  // Prevent doing this for each SSR request
  !asyncData && Component.options.__hasNuxtData) {
    return;
  }
  const ComponentData = Component.options._originDataFn || Component.options.data || function () {
    return {};
  };
  Component.options._originDataFn = ComponentData;
  Component.options.data = function () {
    const data = ComponentData.call(this, this);
    if (this.$ssrContext) {
      asyncData = this.$ssrContext.asyncData[Component.cid];
    }
    return {
      ...data,
      ...asyncData
    };
  };
  Component.options.__hasNuxtData = true;
  if (Component._Ctor && Component._Ctor.options) {
    Component._Ctor.options.data = Component.options.data;
  }
}
function sanitizeComponent(Component) {
  // If Component already sanitized
  if (Component.options && Component._Ctor === Component) {
    return Component;
  }
  if (!Component.options) {
    Component = external_vue_default.a.extend(Component); // fix issue #6
    Component._Ctor = Component;
  } else {
    Component._Ctor = Component;
    Component.extendOptions = Component.options;
  }
  // If no component name defined, set file path as name, (also fixes #5703)
  if (!Component.options.name && Component.options.__file) {
    Component.options.name = Component.options.__file;
  }
  return Component;
}
function getMatchedComponents(route, matches = false, prop = 'components') {
  return Array.prototype.concat.apply([], route.matched.map((m, index) => {
    return Object.keys(m[prop]).map(key => {
      matches && matches.push(index);
      return m[prop][key];
    });
  }));
}
function getMatchedComponentsInstances(route, matches = false) {
  return getMatchedComponents(route, matches, 'instances');
}
function flatMapComponents(route, fn) {
  return Array.prototype.concat.apply([], route.matched.map((m, index) => {
    return Object.keys(m.components).reduce((promises, key) => {
      if (m.components[key]) {
        promises.push(fn(m.components[key], m.instances[key], m, key, index));
      } else {
        delete m.components[key];
      }
      return promises;
    }, []);
  }));
}
function resolveRouteComponents(route, fn) {
  return Promise.all(flatMapComponents(route, async (Component, instance, match, key) => {
    // If component is a function, resolve it
    if (typeof Component === 'function' && !Component.options) {
      try {
        Component = await Component();
      } catch (error) {
        // Handle webpack chunk loading errors
        // This may be due to a new deployment or a network problem
        if (error && error.name === 'ChunkLoadError' && typeof window !== 'undefined' && window.sessionStorage) {
          const timeNow = Date.now();
          const previousReloadTime = parseInt(window.sessionStorage.getItem('nuxt-reload'));

          // check for previous reload time not to reload infinitely
          if (!previousReloadTime || previousReloadTime + 60000 < timeNow) {
            window.sessionStorage.setItem('nuxt-reload', timeNow);
            window.location.reload(true /* skip cache */);
          }
        }

        throw error;
      }
    }
    match.components[key] = Component = sanitizeComponent(Component);
    return typeof fn === 'function' ? fn(Component, instance, match, key) : Component;
  }));
}
async function getRouteData(route) {
  if (!route) {
    return;
  }
  // Make sure the components are resolved (code-splitting)
  await resolveRouteComponents(route);
  // Send back a copy of route with meta based on Component definition
  return {
    ...route,
    meta: getMatchedComponents(route).map((Component, index) => {
      return {
        ...Component.options.meta,
        ...(route.matched[index] || {}).meta
      };
    })
  };
}
async function setContext(app, context) {
  // If context not defined, create it
  if (!app.context) {
    app.context = {
      isStatic: false,
      isDev: false,
      isHMR: false,
      app,
      store: app.store,
      payload: context.payload,
      error: context.error,
      base: app.router.options.base,
      env: {}
    };
    // Only set once

    if (context.req) {
      app.context.req = context.req;
    }
    if (context.res) {
      app.context.res = context.res;
    }
    if (context.ssrContext) {
      app.context.ssrContext = context.ssrContext;
    }
    app.context.redirect = (status, path, query) => {
      if (!status) {
        return;
      }
      app.context._redirected = true;
      // if only 1 or 2 arguments: redirect('/') or redirect('/', { foo: 'bar' })
      let pathType = typeof path;
      if (typeof status !== 'number' && (pathType === 'undefined' || pathType === 'object')) {
        query = path || {};
        path = status;
        pathType = typeof path;
        status = 302;
      }
      if (pathType === 'object') {
        path = app.router.resolve(path).route.fullPath;
      }
      // "/absolute/route", "./relative/route" or "../relative/route"
      if (/(^[.]{1,2}\/)|(^\/(?!\/))/.test(path)) {
        app.context.next({
          path,
          query,
          status
        });
      } else {
        path = Object(external_ufo_["withQuery"])(path, query);
        if (true) {
          app.context.next({
            path,
            status
          });
        }
        if (false) {}
      }
    };
    if (true) {
      app.context.beforeNuxtRender = fn => context.beforeRenderFns.push(fn);
    }
    if (false) {}
  }

  // Dynamic keys
  const [currentRouteData, fromRouteData] = await Promise.all([getRouteData(context.route), getRouteData(context.from)]);
  if (context.route) {
    app.context.route = currentRouteData;
  }
  if (context.from) {
    app.context.from = fromRouteData;
  }
  app.context.next = context.next;
  app.context._redirected = false;
  app.context._errored = false;
  app.context.isHMR = false;
  app.context.params = app.context.route.params || {};
  app.context.query = app.context.route.query || {};
}
function middlewareSeries(promises, appContext) {
  if (!promises.length || appContext._redirected || appContext._errored) {
    return Promise.resolve();
  }
  return promisify(promises[0], appContext).then(() => {
    return middlewareSeries(promises.slice(1), appContext);
  });
}
function promisify(fn, context) {
  let promise;
  if (fn.length === 2) {
    // fn(context, callback)
    promise = new Promise(resolve => {
      fn(context, function (err, data) {
        if (err) {
          context.error(err);
        }
        data = data || {};
        resolve(data);
      });
    });
  } else {
    promise = fn(context);
  }
  if (promise && promise instanceof Promise && typeof promise.then === 'function') {
    return promise;
  }
  return Promise.resolve(promise);
}

// Imported from vue-router
function getLocation(base, mode) {
  if (mode === 'hash') {
    return window.location.hash.replace(/^#\//, '');
  }
  base = decodeURI(base).slice(0, -1); // consideration is base is normalized with trailing slash
  let path = decodeURI(window.location.pathname);
  if (base && path.startsWith(base)) {
    path = path.slice(base.length);
  }
  const fullPath = (path || '/') + window.location.search + window.location.hash;
  return Object(external_ufo_["normalizeURL"])(fullPath);
}

// Imported from path-to-regexp

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function getQueryDiff(toQuery, fromQuery) {
  const diff = {};
  const queries = {
    ...toQuery,
    ...fromQuery
  };
  for (const k in queries) {
    if (String(toQuery[k]) !== String(fromQuery[k])) {
      diff[k] = true;
    }
  }
  return diff;
}
function normalizeError(err) {
  let message;
  if (!(err.message || typeof err === 'string')) {
    try {
      message = JSON.stringify(err, null, 2);
    } catch (e) {
      message = `[${err.constructor.name}]`;
    }
  } else {
    message = err.message || err;
  }
  return {
    ...err,
    message,
    statusCode: err.statusCode || err.status || err.response && err.response.status || 500
  };
}

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
const PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  const tokens = [];
  let key = 0;
  let index = 0;
  let path = '';
  const defaultDelimiter = options && options.delimiter || '/';
  let res;
  while ((res = PATH_REGEXP.exec(str)) != null) {
    const m = res[0];
    const escaped = res[1];
    const offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }
    const next = str[index];
    const prefix = res[2];
    const name = res[3];
    const capture = res[4];
    const group = res[5];
    const modifier = res[6];
    const asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }
    const partial = prefix != null && next != null && next !== prefix;
    const repeat = modifier === '+' || modifier === '*';
    const optional = modifier === '?' || modifier === '*';
    const delimiter = res[2] || defaultDelimiter;
    const pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter,
      optional,
      repeat,
      partial,
      asterisk: Boolean(asterisk),
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }
  return tokens;
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str, slashAllowed) {
  const re = slashAllowed ? /[?#]/g : /[/?#]/g;
  return encodeURI(str).replace(re, c => {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURIComponentPretty(str, true);
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$/()])/g, '\\$1');
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
  // Compile all the tokens into regexps.
  const matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (let i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }
  return function (obj, opts) {
    let path = '';
    const data = obj || {};
    const options = opts || {};
    const encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (typeof token === 'string') {
        path += token;
        continue;
      }
      const value = data[token.name || 'pathMatch'];
      let segment;
      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }
          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }
      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }
        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }
        for (let j = 0; j < value.length; j++) {
          segment = encode(value[j]);
          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }
          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }
        continue;
      }
      segment = token.asterisk ? encodeAsterisk(value) : encode(value);
      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }
      path += token.prefix + segment;
    }
    return path;
  };
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options && options.sensitive ? '' : 'i';
}
function addLifecycleHook(vm, hook, fn) {
  if (!vm.$options[hook]) {
    vm.$options[hook] = [];
  }
  if (!vm.$options[hook].includes(fn)) {
    vm.$options[hook].push(fn);
  }
}
const urlJoin = external_ufo_["joinURL"];
const stripTrailingSlash = external_ufo_["withoutTrailingSlash"];
const isSamePath = external_ufo_["isSamePath"];
function setScrollRestoration(newVal) {
  try {
    window.history.scrollRestoration = newVal;
  } catch (e) {}
}
// CONCATENATED MODULE: ./.nuxt/mixins/fetch.server.js


async function serverPrefetch() {
  if (!this._fetchOnServer) {
    return;
  }

  // Call and await on $fetch
  try {
    await this.$options.fetch.call(this);
  } catch (err) {
    if (false) {}
    this.$fetchState.error = normalizeError(err);
  }
  this.$fetchState.pending = false;

  // Define an ssrKey for hydration
  this._fetchKey = this._fetchKey || this.$ssrContext.fetchCounters['']++;

  // Add data-fetch-key on parent element of Component
  const attrs = this.$vnode.data.attrs = this.$vnode.data.attrs || {};
  attrs['data-fetch-key'] = this._fetchKey;

  // Add to ssrContext for window.__NUXT__.fetch

  this.$ssrContext.nuxt.fetch[this._fetchKey] = this.$fetchState.error ? {
    _error: this.$fetchState.error
  } : purifyData(this._data);
}
/* harmony default export */ var fetch_server = ({
  created() {
    if (!hasFetch(this)) {
      return;
    }
    if (typeof this.$options.fetchOnServer === 'function') {
      this._fetchOnServer = this.$options.fetchOnServer.call(this) !== false;
    } else {
      this._fetchOnServer = this.$options.fetchOnServer !== false;
    }
    const defaultKey = this.$options._scopeId || this.$options.name || '';
    const getCounter = createGetCounter(this.$ssrContext.fetchCounters, defaultKey);
    if (typeof this.$options.fetchKey === 'function') {
      this._fetchKey = this.$options.fetchKey.call(this, getCounter);
    } else {
      const key = 'string' === typeof this.$options.fetchKey ? this.$options.fetchKey : defaultKey;
      this._fetchKey = key ? key + ':' + getCounter(key) : String(getCounter(key));
    }

    // Added for remove vue undefined warning while ssr
    this.$fetch = () => {}; // issue #8043
    external_vue_default.a.util.defineReactive(this, '$fetchState', {
      pending: true,
      error: null,
      timestamp: Date.now()
    });
    addLifecycleHook(this, 'serverPrefetch', serverPrefetch);
  }
});
// EXTERNAL MODULE: external "vuex"
var external_vuex_ = __webpack_require__(4);
var external_vuex_default = /*#__PURE__*/__webpack_require__.n(external_vuex_);

// EXTERNAL MODULE: external "vue-meta"
var external_vue_meta_ = __webpack_require__(14);
var external_vue_meta_default = /*#__PURE__*/__webpack_require__.n(external_vue_meta_);

// EXTERNAL MODULE: external "vue-client-only"
var external_vue_client_only_ = __webpack_require__(9);
var external_vue_client_only_default = /*#__PURE__*/__webpack_require__.n(external_vue_client_only_);

// EXTERNAL MODULE: external "vue-no-ssr"
var external_vue_no_ssr_ = __webpack_require__(5);
var external_vue_no_ssr_default = /*#__PURE__*/__webpack_require__.n(external_vue_no_ssr_);

// EXTERNAL MODULE: external "vue-router"
var external_vue_router_ = __webpack_require__(10);
var external_vue_router_default = /*#__PURE__*/__webpack_require__.n(external_vue_router_);

// CONCATENATED MODULE: ./.nuxt/router.scrollBehavior.js

if (false) {}
function shouldScrollToTop(route) {
  const Pages = getMatchedComponents(route);
  if (Pages.length === 1) {
    const {
      options = {}
    } = Pages[0];
    return options.scrollToTop !== false;
  }
  return Pages.some(({
    options
  }) => options && options.scrollToTop);
}
/* harmony default export */ var router_scrollBehavior = (function (to, from, savedPosition) {
  // If the returned position is falsy or an empty object, will retain current scroll position
  let position = false;
  const isRouteChanged = to !== from;

  // savedPosition is only available for popstate navigations (back button)
  if (savedPosition) {
    position = savedPosition;
  } else if (isRouteChanged && shouldScrollToTop(to)) {
    position = {
      x: 0,
      y: 0
    };
  }
  const nuxt = window.$nuxt;
  if (
  // Initial load (vuejs/vue-router#3199)
  !isRouteChanged ||
  // Route hash changes
  to.path === from.path && to.hash !== from.hash) {
    nuxt.$nextTick(() => nuxt.$emit('triggerScroll'));
  }
  return new Promise(resolve => {
    // wait for the out transition to complete (if necessary)
    nuxt.$once('triggerScroll', () => {
      // coords will be used if no selector is provided,
      // or if the selector didn't match any element.
      if (to.hash) {
        let hash = to.hash;
        // CSS.escape() is not supported with IE and Edge.
        if (typeof window.CSS !== 'undefined' && typeof window.CSS.escape !== 'undefined') {
          hash = '#' + window.CSS.escape(hash.substr(1));
        }
        try {
          if (document.querySelector(hash)) {
            // scroll to anchor by returning the selector
            position = {
              selector: hash
            };
          }
        } catch (e) {
          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (https://github.com/mathiasbynens/CSS.escape).');
        }
      }
      resolve(position);
    });
  });
});
// CONCATENATED MODULE: ./.nuxt/router.js





const _7aba7cfa = () => interopDefault(__webpack_require__.e(/* import() | pages/index */ 8).then(__webpack_require__.bind(null, 67)));

const emptyFn = () => {};
external_vue_default.a.use(external_vue_router_default.a);
const routerOptions = {
  mode: 'history',
  base: '/',
  linkActiveClass: 'nuxt-link-active',
  linkExactActiveClass: 'nuxt-link-exact-active',
  scrollBehavior: router_scrollBehavior,
  routes: [{
    path: "/",
    component: _7aba7cfa,
    name: "index"
  }],
  fallback: false
};
function createRouter(ssrContext, config) {
  const base = config._app && config._app.basePath || routerOptions.base;
  const router = new external_vue_router_default.a({
    ...routerOptions,
    base
  });

  // TODO: remove in Nuxt 3
  const originalPush = router.push;
  router.push = function push(location, onComplete = emptyFn, onAbort) {
    return originalPush.call(this, location, onComplete, onAbort);
  };
  const resolve = router.resolve.bind(router);
  router.resolve = (to, current, append) => {
    if (typeof to === 'string') {
      to = Object(external_ufo_["normalizeURL"])(to);
    }
    return resolve(to, current, append);
  };
  return router;
}
// CONCATENATED MODULE: ./.nuxt/components/nuxt-child.js
/* harmony default export */ var nuxt_child = ({
  name: 'NuxtChild',
  functional: true,
  props: {
    nuxtChildKey: {
      type: String,
      default: ''
    },
    keepAlive: Boolean,
    keepAliveProps: {
      type: Object,
      default: undefined
    }
  },
  render(_, {
    parent,
    data,
    props
  }) {
    const h = parent.$createElement;
    data.nuxtChild = true;
    const _parent = parent;
    const transitions = parent.$nuxt.nuxt.transitions;
    const defaultTransition = parent.$nuxt.nuxt.defaultTransition;
    let depth = 0;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.nuxtChild) {
        depth++;
      }
      parent = parent.$parent;
    }
    data.nuxtChildDepth = depth;
    const transition = transitions[depth] || defaultTransition;
    const transitionProps = {};
    transitionsKeys.forEach(key => {
      if (typeof transition[key] !== 'undefined') {
        transitionProps[key] = transition[key];
      }
    });
    const listeners = {};
    listenersKeys.forEach(key => {
      if (typeof transition[key] === 'function') {
        listeners[key] = transition[key].bind(_parent);
      }
    });
    if (false) {}

    // make sure that leave is called asynchronous (fix #5703)
    if (transition.css === false) {
      const leave = listeners.leave;

      // only add leave listener when user didnt provide one
      // or when it misses the done argument
      if (!leave || leave.length < 2) {
        listeners.leave = (el, done) => {
          if (leave) {
            leave.call(_parent, el);
          }
          _parent.$nextTick(done);
        };
      }
    }
    let routerView = h('routerView', data);
    if (props.keepAlive) {
      routerView = h('keep-alive', {
        props: props.keepAliveProps
      }, [routerView]);
    }
    return h('transition', {
      props: transitionProps,
      on: listeners
    }, [routerView]);
  }
});
const transitionsKeys = ['name', 'mode', 'appear', 'css', 'type', 'duration', 'enterClass', 'leaveClass', 'appearClass', 'enterActiveClass', 'enterActiveClass', 'leaveActiveClass', 'appearActiveClass', 'enterToClass', 'leaveToClass', 'appearToClass'];
const listenersKeys = ['beforeEnter', 'enter', 'afterEnter', 'enterCancelled', 'beforeLeave', 'leave', 'afterLeave', 'leaveCancelled', 'beforeAppear', 'appear', 'afterAppear', 'appearCancelled'];
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./.nuxt/components/nuxt-error.vue?vue&type=template&id=5eb69f1c&
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c('div', {
    staticClass: "__nuxt-error-page"
  }, [_vm._ssrNode("<div class=\"error\">", "</div>", [_vm._ssrNode("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"90\" height=\"90\" fill=\"#DBE1EC\" viewBox=\"0 0 48 48\"><path d=\"M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z\"></path></svg> <div class=\"title\">" + _vm._ssrEscape(_vm._s(_vm.message)) + "</div> "), _vm.statusCode === 404 ? _vm._ssrNode("<p class=\"description\">", "</p>", [typeof _vm.$route === 'undefined' ? _vm._ssrNode("<a href=\"/\" class=\"error-link\">", "</a>") : _c('NuxtLink', {
    staticClass: "error-link",
    attrs: {
      "to": "/"
    }
  }, [_vm._v("Back to the home page")])], 1) : _vm._e(), _vm._ssrNode(" <div class=\"logo\"><a href=\"https://nuxtjs.org\" target=\"_blank\" rel=\"noopener\">Nuxt</a></div>")], 2)]);
};
var staticRenderFns = [];

// CONCATENATED MODULE: ./.nuxt/components/nuxt-error.vue?vue&type=template&id=5eb69f1c&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./.nuxt/components/nuxt-error.vue?vue&type=script&lang=js&
/* harmony default export */ var nuxt_errorvue_type_script_lang_js_ = ({
  name: 'NuxtError',
  props: {
    error: {
      type: Object,
      default: null
    }
  },
  computed: {
    statusCode() {
      return this.error && this.error.statusCode || 500;
    },
    message() {
      return this.error.message || 'Error';
    }
  },
  head() {
    return {
      title: this.message,
      meta: [{
        name: 'viewport',
        content: 'width=device-width,initial-scale=1.0,minimum-scale=1.0'
      }]
    };
  }
});
// CONCATENATED MODULE: ./.nuxt/components/nuxt-error.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_nuxt_errorvue_type_script_lang_js_ = (nuxt_errorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(2);

// CONCATENATED MODULE: ./.nuxt/components/nuxt-error.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(19)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var nuxt_error_component = Object(componentNormalizer["a" /* default */])(
  components_nuxt_errorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  null,
  "54ff8b3c"
  
)

/* harmony default export */ var nuxt_error = (nuxt_error_component.exports);
// CONCATENATED MODULE: ./.nuxt/components/nuxt.js




/* harmony default export */ var components_nuxt = ({
  name: 'Nuxt',
  components: {
    NuxtChild: nuxt_child,
    NuxtError: nuxt_error
  },
  props: {
    nuxtChildKey: {
      type: String,
      default: undefined
    },
    keepAlive: Boolean,
    keepAliveProps: {
      type: Object,
      default: undefined
    },
    name: {
      type: String,
      default: 'default'
    }
  },
  errorCaptured(error) {
    // if we receive and error while showing the NuxtError component
    // capture the error and force an immediate update so we re-render
    // without the NuxtError component
    if (this.displayingNuxtError) {
      this.errorFromNuxtError = error;
      this.$forceUpdate();
    }
  },
  computed: {
    routerViewKey() {
      // If nuxtChildKey prop is given or current route has children
      if (typeof this.nuxtChildKey !== 'undefined' || this.$route.matched.length > 1) {
        return this.nuxtChildKey || compile(this.$route.matched[0].path)(this.$route.params);
      }
      const [matchedRoute] = this.$route.matched;
      if (!matchedRoute) {
        return this.$route.path;
      }
      const Component = matchedRoute.components.default;
      if (Component && Component.options) {
        const {
          options
        } = Component;
        if (options.key) {
          return typeof options.key === 'function' ? options.key(this.$route) : options.key;
        }
      }
      const strict = /\/$/.test(matchedRoute.path);
      return strict ? this.$route.path : this.$route.path.replace(/\/$/, '');
    }
  },
  beforeCreate() {
    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$root.$options.nuxt);
  },
  render(h) {
    // if there is no error
    if (!this.nuxt.err) {
      // Directly return nuxt child
      return h('NuxtChild', {
        key: this.routerViewKey,
        props: this.$props
      });
    }

    // if an error occurred within NuxtError show a simple
    // error message instead to prevent looping
    if (this.errorFromNuxtError) {
      this.$nextTick(() => this.errorFromNuxtError = false);
      return h('div', {}, [h('h2', 'An error occurred while showing the error page'), h('p', 'Unfortunately an error occurred and while showing the error page another error occurred'), h('p', `Error details: ${this.errorFromNuxtError.toString()}`), h('nuxt-link', {
        props: {
          to: '/'
        }
      }, 'Go back to home')]);
    }

    // track if we are showing the NuxtError component
    this.displayingNuxtError = true;
    this.$nextTick(() => this.displayingNuxtError = false);
    return h(nuxt_error, {
      props: {
        error: this.nuxt.err
      }
    });
  }
});
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./.nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&
/* harmony default export */ var nuxt_loadingvue_type_script_lang_js_ = ({
  name: 'NuxtLoading',
  data() {
    return {
      percent: 0,
      show: false,
      canSucceed: true,
      reversed: false,
      skipTimerCount: 0,
      rtl: false,
      throttle: 200,
      duration: 5000,
      continuous: false
    };
  },
  computed: {
    left() {
      if (!this.continuous && !this.rtl) {
        return false;
      }
      return this.rtl ? this.reversed ? '0px' : 'auto' : !this.reversed ? '0px' : 'auto';
    }
  },
  beforeDestroy() {
    this.clear();
  },
  methods: {
    clear() {
      clearInterval(this._timer);
      clearTimeout(this._throttle);
      this._timer = null;
    },
    start() {
      this.clear();
      this.percent = 0;
      this.reversed = false;
      this.skipTimerCount = 0;
      this.canSucceed = true;
      if (this.throttle) {
        this._throttle = setTimeout(() => this.startTimer(), this.throttle);
      } else {
        this.startTimer();
      }
      return this;
    },
    set(num) {
      this.show = true;
      this.canSucceed = true;
      this.percent = Math.min(100, Math.max(0, Math.floor(num)));
      return this;
    },
    get() {
      return this.percent;
    },
    increase(num) {
      this.percent = Math.min(100, Math.floor(this.percent + num));
      return this;
    },
    decrease(num) {
      this.percent = Math.max(0, Math.floor(this.percent - num));
      return this;
    },
    pause() {
      clearInterval(this._timer);
      return this;
    },
    resume() {
      this.startTimer();
      return this;
    },
    finish() {
      this.percent = this.reversed ? 0 : 100;
      this.hide();
      return this;
    },
    hide() {
      this.clear();
      setTimeout(() => {
        this.show = false;
        this.$nextTick(() => {
          this.percent = 0;
          this.reversed = false;
        });
      }, 500);
      return this;
    },
    fail(error) {
      this.canSucceed = false;
      return this;
    },
    startTimer() {
      if (!this.show) {
        this.show = true;
      }
      if (typeof this._cut === 'undefined') {
        this._cut = 10000 / Math.floor(this.duration);
      }
      this._timer = setInterval(() => {
        /**
         * When reversing direction skip one timers
         * so 0, 100 are displayed for two iterations
         * also disable css width transitioning
         * which otherwise interferes and shows
         * a jojo effect
         */
        if (this.skipTimerCount > 0) {
          this.skipTimerCount--;
          return;
        }
        if (this.reversed) {
          this.decrease(this._cut);
        } else {
          this.increase(this._cut);
        }
        if (this.continuous) {
          if (this.percent >= 100) {
            this.skipTimerCount = 1;
            this.reversed = !this.reversed;
          } else if (this.percent <= 0) {
            this.skipTimerCount = 1;
            this.reversed = !this.reversed;
          }
        }
      }, 100);
    }
  },
  render(h) {
    let el = h(false);
    if (this.show) {
      el = h('div', {
        staticClass: 'nuxt-progress',
        class: {
          'nuxt-progress-notransition': this.skipTimerCount > 0,
          'nuxt-progress-failed': !this.canSucceed
        },
        style: {
          width: this.percent + '%',
          left: this.left
        }
      });
    }
    return el;
  }
});
// CONCATENATED MODULE: ./.nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_nuxt_loadingvue_type_script_lang_js_ = (nuxt_loadingvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./.nuxt/components/nuxt-loading.vue
var nuxt_loading_render, nuxt_loading_staticRenderFns


function nuxt_loading_injectStyles (context) {
  
  var style0 = __webpack_require__(21)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var nuxt_loading_component = Object(componentNormalizer["a" /* default */])(
  components_nuxt_loadingvue_type_script_lang_js_,
  nuxt_loading_render,
  nuxt_loading_staticRenderFns,
  false,
  nuxt_loading_injectStyles,
  null,
  "ecbead20"
  
)

/* harmony default export */ var nuxt_loading = (nuxt_loading_component.exports);
// EXTERNAL MODULE: ./assets/styles/main.scss
var main = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./.nuxt/layouts/default.vue?vue&type=template&id=0040005c&
var defaultvue_type_template_id_0040005c_render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c('Nuxt');
};
var defaultvue_type_template_id_0040005c_staticRenderFns = [];

// CONCATENATED MODULE: ./.nuxt/layouts/default.vue?vue&type=template&id=0040005c&

// CONCATENATED MODULE: ./.nuxt/layouts/default.vue

var script = {}


/* normalize component */

var default_component = Object(componentNormalizer["a" /* default */])(
  script,
  defaultvue_type_template_id_0040005c_render,
  defaultvue_type_template_id_0040005c_staticRenderFns,
  false,
  null,
  null,
  "745e3860"
  
)

/* harmony default export */ var layouts_default = (default_component.exports);
// CONCATENATED MODULE: ./.nuxt/App.js







const layouts = {
  "_default": sanitizeComponent(layouts_default)
};
/* harmony default export */ var App = ({
  render(h, props) {
    const loadingEl = h('NuxtLoading', {
      ref: 'loading'
    });
    const layoutEl = h(this.layout || 'nuxt');
    const templateEl = h('div', {
      domProps: {
        id: '__layout'
      },
      key: this.layoutName
    }, [layoutEl]);
    const transitionEl = h('transition', {
      props: {
        name: 'layout',
        mode: 'out-in'
      },
      on: {
        beforeEnter(el) {
          // Ensure to trigger scroll event after calling scrollBehavior
          window.$nuxt.$nextTick(() => {
            window.$nuxt.$emit('triggerScroll');
          });
        }
      }
    }, [templateEl]);
    return h('div', {
      domProps: {
        id: '__nuxt'
      }
    }, [loadingEl, transitionEl]);
  },
  data: () => ({
    isOnline: true,
    layout: null,
    layoutName: '',
    nbFetching: 0
  }),
  beforeCreate() {
    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$options.nuxt);
  },
  created() {
    // Add this.$nuxt in child instances
    this.$root.$options.$nuxt = this;
    if (false) {}
    // Add $nuxt.error()
    this.error = this.nuxt.error;
    // Add $nuxt.context
    this.context = this.$options.context;
  },
  async mounted() {
    this.$loading = this.$refs.loading;
  },
  watch: {
    'nuxt.err': 'errorChanged'
  },
  computed: {
    isOffline() {
      return !this.isOnline;
    },
    isFetching() {
      return this.nbFetching > 0;
    }
  },
  methods: {
    refreshOnlineStatus() {
      if (false) {}
    },
    async refresh() {
      const pages = getMatchedComponentsInstances(this.$route);
      if (!pages.length) {
        return;
      }
      this.$loading.start();
      const promises = pages.map(page => {
        const p = [];

        // Old fetch
        if (page.$options.fetch && page.$options.fetch.length) {
          p.push(promisify(page.$options.fetch, this.context));
        }
        if (page.$fetch) {
          p.push(page.$fetch());
        } else {
          // Get all component instance to call $fetch
          for (const component of getChildrenComponentInstancesUsingFetch(page.$vnode.componentInstance)) {
            p.push(component.$fetch());
          }
        }
        if (page.$options.asyncData) {
          p.push(promisify(page.$options.asyncData, this.context).then(newData => {
            for (const key in newData) {
              external_vue_default.a.set(page.$data, key, newData[key]);
            }
          }));
        }
        return Promise.all(p);
      });
      try {
        await Promise.all(promises);
      } catch (error) {
        this.$loading.fail(error);
        globalHandleError(error);
        this.error(error);
      }
      this.$loading.finish();
    },
    errorChanged() {
      if (this.nuxt.err) {
        if (this.$loading) {
          if (this.$loading.fail) {
            this.$loading.fail(this.nuxt.err);
          }
          if (this.$loading.finish) {
            this.$loading.finish();
          }
        }
        let errorLayout = (nuxt_error.options || nuxt_error).layout;
        if (typeof errorLayout === 'function') {
          errorLayout = errorLayout(this.context);
        }
        this.setLayout(errorLayout);
      }
    },
    setLayout(layout) {
      if (!layout || !layouts['_' + layout]) {
        layout = 'default';
      }
      this.layoutName = layout;
      this.layout = layouts['_' + layout];
      return this.layout;
    },
    loadLayout(layout) {
      if (!layout || !layouts['_' + layout]) {
        layout = 'default';
      }
      return Promise.resolve(layouts['_' + layout]);
    }
  },
  components: {
    NuxtLoading: nuxt_loading
  }
});
// CONCATENATED MODULE: ./.nuxt/store.js


external_vue_default.a.use(external_vuex_default.a);
const VUEX_PROPERTIES = ['state', 'getters', 'actions', 'mutations'];
let store_store = {};
(function updateModules() {
  // If store is an exported method = classic mode (deprecated)

  // Enforce store modules
  store_store.modules = store_store.modules || {};
  resolveStoreModules(__webpack_require__(26), 'popup.js');

  // If the environment supports hot reloading...
})();

// createStore
const createStore = store_store instanceof Function ? store_store : () => {
  return new external_vuex_default.a.Store(Object.assign({
    strict: "production" !== 'production'
  }, store_store));
};
function normalizeRoot(moduleData, filePath) {
  moduleData = moduleData.default || moduleData;
  if (moduleData.commit) {
    throw new Error(`[nuxt] ${filePath} should export a method that returns a Vuex instance.`);
  }
  if (typeof moduleData !== 'function') {
    // Avoid TypeError: setting a property that has only a getter when overwriting top level keys
    moduleData = Object.assign({}, moduleData);
  }
  return normalizeModule(moduleData, filePath);
}
function normalizeModule(moduleData, filePath) {
  if (moduleData.state && typeof moduleData.state !== 'function') {
    console.warn(`'state' should be a method that returns an object in ${filePath}`);
    const state = Object.assign({}, moduleData.state);
    // Avoid TypeError: setting a property that has only a getter when overwriting top level keys
    moduleData = Object.assign({}, moduleData, {
      state: () => state
    });
  }
  return moduleData;
}
function resolveStoreModules(moduleData, filename) {
  moduleData = moduleData.default || moduleData;
  // Remove store src + extension (./foo/index.js -> foo/index)
  const namespace = filename.replace(/\.(js|mjs)$/, '');
  const namespaces = namespace.split('/');
  let moduleName = namespaces[namespaces.length - 1];
  const filePath = `store/${filename}`;
  moduleData = moduleName === 'state' ? normalizeState(moduleData, filePath) : normalizeModule(moduleData, filePath);

  // If src is a known Vuex property
  if (VUEX_PROPERTIES.includes(moduleName)) {
    const property = moduleName;
    const propertyStoreModule = getStoreModule(store_store, namespaces, {
      isProperty: true
    });

    // Replace state since it's a function
    mergeProperty(propertyStoreModule, moduleData, property);
    return;
  }

  // If file is foo/index.js, it should be saved as foo
  const isIndexModule = moduleName === 'index';
  if (isIndexModule) {
    namespaces.pop();
    moduleName = namespaces[namespaces.length - 1];
  }
  const storeModule = getStoreModule(store_store, namespaces);
  for (const property of VUEX_PROPERTIES) {
    mergeProperty(storeModule, moduleData[property], property);
  }
  if (moduleData.namespaced === false) {
    delete storeModule.namespaced;
  }
}
function normalizeState(moduleData, filePath) {
  if (typeof moduleData !== 'function') {
    console.warn(`${filePath} should export a method that returns an object`);
    const state = Object.assign({}, moduleData);
    return () => state;
  }
  return normalizeModule(moduleData, filePath);
}
function getStoreModule(storeModule, namespaces, {
  isProperty = false
} = {}) {
  // If ./mutations.js
  if (!namespaces.length || isProperty && namespaces.length === 1) {
    return storeModule;
  }
  const namespace = namespaces.shift();
  storeModule.modules[namespace] = storeModule.modules[namespace] || {};
  storeModule.modules[namespace].namespaced = true;
  storeModule.modules[namespace].modules = storeModule.modules[namespace].modules || {};
  return getStoreModule(storeModule.modules[namespace], namespaces, {
    isProperty
  });
}
function mergeProperty(storeModule, moduleData, property) {
  if (!moduleData) {
    return;
  }
  if (property === 'state') {
    storeModule.state = moduleData || storeModule.state;
  } else {
    storeModule[property] = Object.assign({}, storeModule[property], moduleData);
  }
}
// CONCATENATED MODULE: ./.nuxt/components/index.js
const VForm = () => __webpack_require__.e(/* import() | components/v-form */ 1).then(__webpack_require__.bind(null, 68)).then(c => wrapFunctional(c.default || c));
const VHeader = () => __webpack_require__.e(/* import() | components/v-header */ 2).then(__webpack_require__.bind(null, 58)).then(c => wrapFunctional(c.default || c));
const VHero = () => __webpack_require__.e(/* import() | components/v-hero */ 3).then(__webpack_require__.bind(null, 60)).then(c => wrapFunctional(c.default || c));
const VPopup = () => __webpack_require__.e(/* import() | components/v-popup */ 4).then(__webpack_require__.bind(null, 59)).then(c => wrapFunctional(c.default || c));
const VRewards = () => __webpack_require__.e(/* import() | components/v-rewards */ 5).then(__webpack_require__.bind(null, 36)).then(c => wrapFunctional(c.default || c));
const VSelect = () => __webpack_require__.e(/* import() | components/v-select */ 6).then(__webpack_require__.bind(null, 30)).then(c => wrapFunctional(c.default || c));
const VTimer = () => __webpack_require__.e(/* import() | components/v-timer */ 7).then(__webpack_require__.bind(null, 37)).then(c => wrapFunctional(c.default || c));

// nuxt/nuxt.js#8607
function wrapFunctional(options) {
  if (!options || !options.functional) {
    return options;
  }
  const propKeys = Array.isArray(options.props) ? options.props : Object.keys(options.props || {});
  return {
    render(h) {
      const attrs = {};
      const props = {};
      for (const key in this.$attrs) {
        if (propKeys.includes(key)) {
          props[key] = this.$attrs[key];
        } else {
          attrs[key] = this.$attrs[key];
        }
      }
      return h(options, {
        on: this.$listeners,
        attrs,
        props,
        scopedSlots: this.$scopedSlots
      }, this.$slots.default);
    }
  };
}
// CONCATENATED MODULE: ./.nuxt/components/plugin.js


for (const name in components_namespaceObject) {
  external_vue_default.a.component(name, components_namespaceObject[name]);
  external_vue_default.a.component('Lazy' + name, components_namespaceObject[name]);
}
// EXTERNAL MODULE: external "vue-the-mask"
var external_vue_the_mask_ = __webpack_require__(15);
var external_vue_the_mask_default = /*#__PURE__*/__webpack_require__.n(external_vue_the_mask_);

// CONCATENATED MODULE: ./plugins/mask.js


external_vue_default.a.use(external_vue_the_mask_default.a);
// EXTERNAL MODULE: ./node_modules/vee-validate/dist/vee-validate.js
var vee_validate = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/vee-validate/dist/rules.js
var rules = __webpack_require__(8);

// CONCATENATED MODULE: ./plugins/vee-validate.js



Object(vee_validate["extend"])('required', rules["b" /* required */]);
Object(vee_validate["extend"])('min', rules["a" /* min */]);
Object(vee_validate["configure"])({
  classes: {
    invalid: 'is-danger'
  }
});
external_vue_default.a.component('ValidationProvider', vee_validate["ValidationProvider"]);
external_vue_default.a.component('ValidationObserver', vee_validate["ValidationObserver"]);
// CONCATENATED MODULE: ./.nuxt/index.js













/* Plugins */

 // Source: ./components/plugin.js (mode: 'all')
 // Source: ../plugins/mask (mode: 'all')
 // Source: ../plugins/vee-validate (mode: 'all')

// Component: <ClientOnly>
external_vue_default.a.component(external_vue_client_only_default.a.name, external_vue_client_only_default.a);

// TODO: Remove in Nuxt 3: <NoSsr>
external_vue_default.a.component(external_vue_no_ssr_default.a.name, {
  ...external_vue_no_ssr_default.a,
  render(h, ctx) {
    if (false) {}
    return external_vue_no_ssr_default.a.render(h, ctx);
  }
});

// Component: <NuxtChild>
external_vue_default.a.component(nuxt_child.name, nuxt_child);
external_vue_default.a.component('NChild', nuxt_child);

// Component NuxtLink is imported in server.js or client.js

// Component: <Nuxt>
external_vue_default.a.component(components_nuxt.name, components_nuxt);
Object.defineProperty(external_vue_default.a.prototype, '$nuxt', {
  get() {
    const globalNuxt = this.$root.$options.$nuxt;
    if (false) {}
    return globalNuxt;
  },
  configurable: true
});
external_vue_default.a.use(external_vue_meta_default.a, {
  "keyName": "head",
  "attribute": "data-n-head",
  "ssrAttribute": "data-n-head-ssr",
  "tagIDKeyName": "hid"
});
const defaultTransition = {
  "name": "page",
  "mode": "out-in",
  "appear": false,
  "appearClass": "appear",
  "appearActiveClass": "appear-active",
  "appearToClass": "appear-to"
};
const originalRegisterModule = external_vuex_default.a.Store.prototype.registerModule;
function registerModule(path, rawModule, options = {}) {
  const preserveState =  false && (false);
  return originalRegisterModule.call(this, path, rawModule, {
    preserveState,
    ...options
  });
}
async function createApp(ssrContext, config = {}) {
  const router = await createRouter(ssrContext, config);
  const store = createStore(ssrContext);
  // Add this.$router into store actions/mutations
  store.$router = router;

  // Fix SSR caveat https://github.com/nuxt/nuxt.js/issues/3757#issuecomment-414689141
  store.registerModule = registerModule;

  // Create Root instance

  // here we inject the router and store to all child components,
  // making them available everywhere as `this.$router` and `this.$store`.
  const app = {
    head: {
      "title": "PlanetLearn",
      "htmlAttrs": {
        "lang": "en"
      },
      "meta": [{
        "charset": "utf-8"
      }, {
        "name": "viewport",
        "content": "width=device-width, initial-scale=1"
      }, {
        "hid": "description",
        "name": "description",
        "content": ""
      }, {
        "name": "format-detection",
        "content": "telephone=no"
      }],
      "link": [{
        "rel": "icon",
        "type": "image\u002Fx-icon",
        "href": "\u002Ffavicon.ico"
      }],
      "style": [],
      "script": []
    },
    store,
    router,
    nuxt: {
      defaultTransition,
      transitions: [defaultTransition],
      setTransitions(transitions) {
        if (!Array.isArray(transitions)) {
          transitions = [transitions];
        }
        transitions = transitions.map(transition => {
          if (!transition) {
            transition = defaultTransition;
          } else if (typeof transition === 'string') {
            transition = Object.assign({}, defaultTransition, {
              name: transition
            });
          } else {
            transition = Object.assign({}, defaultTransition, transition);
          }
          return transition;
        });
        this.$options.nuxt.transitions = transitions;
        return transitions;
      },
      err: null,
      dateErr: null,
      error(err) {
        err = err || null;
        app.context._errored = Boolean(err);
        err = err ? normalizeError(err) : null;
        let nuxt = app.nuxt; // to work with @vue/composition-api, see https://github.com/nuxt/nuxt.js/issues/6517#issuecomment-573280207
        if (this) {
          nuxt = this.nuxt || this.$options.nuxt;
        }
        nuxt.dateErr = Date.now();
        nuxt.err = err;
        // Used in src/server.js
        if (ssrContext) {
          ssrContext.nuxt.error = err;
        }
        return err;
      }
    },
    ...App
  };

  // Make app available into store via this.app
  store.app = app;
  const next = ssrContext ? ssrContext.next : location => app.router.push(location);
  // Resolve route
  let route;
  if (ssrContext) {
    route = router.resolve(ssrContext.url).route;
  } else {
    const path = getLocation(router.options.base, router.options.mode);
    route = router.resolve(path).route;
  }

  // Set context to app.context
  await setContext(app, {
    store,
    route,
    next,
    error: app.nuxt.error.bind(app),
    payload: ssrContext ? ssrContext.payload : undefined,
    req: ssrContext ? ssrContext.req : undefined,
    res: ssrContext ? ssrContext.res : undefined,
    beforeRenderFns: ssrContext ? ssrContext.beforeRenderFns : undefined,
    ssrContext
  });
  function inject(key, value) {
    if (!key) {
      throw new Error('inject(key, value) has no key provided');
    }
    if (value === undefined) {
      throw new Error(`inject('${key}', value) has no value provided`);
    }
    key = '$' + key;
    // Add into app
    app[key] = value;
    // Add into context
    if (!app.context[key]) {
      app.context[key] = value;
    }

    // Add into store
    store[key] = app[key];

    // Check if plugin not already installed
    const installKey = '__nuxt_' + key + '_installed__';
    if (external_vue_default.a[installKey]) {
      return;
    }
    external_vue_default.a[installKey] = true;
    // Call Vue.use() to install the plugin into vm
    external_vue_default.a.use(() => {
      if (!Object.prototype.hasOwnProperty.call(external_vue_default.a.prototype, key)) {
        Object.defineProperty(external_vue_default.a.prototype, key, {
          get() {
            return this.$root.$options[key];
          }
        });
      }
    });
  }

  // Inject runtime config as $config
  inject('config', config);
  if (false) {}

  // Add enablePreview(previewData = {}) in context for plugins
  if (false) {}
  // Plugin execution

  if (typeof /* Cannot get final name for export "default" in "./.nuxt/components/plugin.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./.nuxt/components/plugin.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  }
  if (typeof /* Cannot get final name for export "default" in "./plugins/mask.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./plugins/mask.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  }
  if (typeof /* Cannot get final name for export "default" in "./plugins/vee-validate.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./plugins/vee-validate.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  }

  // Lock enablePreview in context
  if (false) {}

  // Wait for async component to be resolved first
  await new Promise((resolve, reject) => {
    // Ignore 404s rather than blindly replacing URL in browser
    if (false) {}
    router.replace(app.context.route.fullPath, resolve, err => {
      // https://github.com/vuejs/vue-router/blob/v3.4.3/src/util/errors.js
      if (!err._isRouter) return reject(err);
      if (err.type !== 2 /* NavigationFailureType.redirected */) return resolve();

      // navigated to a different route in router guard
      const unregister = router.afterEach(async (to, from) => {
        if ( true && ssrContext && ssrContext.url) {
          ssrContext.url = to.fullPath;
        }
        app.context.route = await getRouteData(to);
        app.context.params = to.params || {};
        app.context.query = to.query || {};
        unregister();
        resolve();
      });
    });
  });
  return {
    store,
    app,
    router
  };
}

// CONCATENATED MODULE: ./.nuxt/components/nuxt-link.server.js

/* harmony default export */ var nuxt_link_server = ({
  name: 'NuxtLink',
  extends: external_vue_default.a.component('RouterLink'),
  props: {
    prefetch: {
      type: Boolean,
      default: true
    },
    noPrefetch: {
      type: Boolean,
      default: false
    }
  }
});
// CONCATENATED MODULE: ./.nuxt/server.js







 // should be included after ./index.js

// Update serverPrefetch strategy
external_vue_default.a.config.optionMergeStrategies.serverPrefetch = external_vue_default.a.config.optionMergeStrategies.created;

// Fetch mixin
if (!external_vue_default.a.__nuxt__fetch__mixin__) {
  external_vue_default.a.mixin(fetch_server);
  external_vue_default.a.__nuxt__fetch__mixin__ = true;
}

// Component: <NuxtLink>
external_vue_default.a.component(nuxt_link_server.name, nuxt_link_server);
external_vue_default.a.component('NLink', nuxt_link_server);
if (!global.fetch) {
  global.fetch = external_node_fetch_default.a;
}
const noopApp = () => new external_vue_default.a({
  render: h => h('div', {
    domProps: {
      id: '__nuxt'
    }
  })
});
const createNext = ssrContext => opts => {
  // If static target, render on client-side
  ssrContext.redirected = opts;
  if (ssrContext.target === 'static' || !ssrContext.res) {
    ssrContext.nuxt.serverRendered = false;
    return;
  }
  let fullPath = Object(external_ufo_["withQuery"])(opts.path, opts.query);
  const $config = ssrContext.runtimeConfig || {};
  const routerBase = $config._app && $config._app.basePath || '/';
  if (!fullPath.startsWith('http') && routerBase !== '/' && !fullPath.startsWith(routerBase)) {
    fullPath = Object(external_ufo_["joinURL"])(routerBase, fullPath);
  }
  // Avoid loop redirect
  if (decodeURI(fullPath) === decodeURI(ssrContext.url)) {
    ssrContext.redirected = false;
    return;
  }
  ssrContext.res.writeHead(opts.status, {
    Location: Object(external_ufo_["normalizeURL"])(fullPath)
  });
  ssrContext.res.end();
};

// This exported function will be called by `bundleRenderer`.
// This is where we perform data-prefetching to determine the
// state of our application before actually rendering it.
// Since data fetching is async, this function is expected to
// return a Promise that resolves to the app instance.
/* harmony default export */ var server = __webpack_exports__["default"] = (async ssrContext => {
  // Create ssrContext.next for simulate next() of beforeEach() when wanted to redirect
  ssrContext.redirected = false;
  ssrContext.next = createNext(ssrContext);
  // Used for beforeNuxtRender({ Components, nuxtState })
  ssrContext.beforeRenderFns = [];
  // Nuxt object (window.{{globals.context}}, defaults to window.__NUXT__)
  ssrContext.nuxt = {
    layout: 'default',
    data: [],
    fetch: {},
    error: null,
    state: null,
    serverRendered: true,
    routePath: ''
  };
  ssrContext.fetchCounters = {};

  // Remove query from url is static target

  // Public runtime config
  ssrContext.nuxt.config = ssrContext.runtimeConfig.public;
  if (ssrContext.nuxt.config._app) {
    __webpack_require__.p = Object(external_ufo_["joinURL"])(ssrContext.nuxt.config._app.cdnURL, ssrContext.nuxt.config._app.assetsPath);
  }
  // Create the app definition and the instance (created for each request)
  const {
    app,
    router,
    store
  } = await createApp(ssrContext, ssrContext.runtimeConfig.private);
  const _app = new external_vue_default.a(app);
  // Add ssr route path to nuxt context so we can account for page navigation between ssr and csr
  ssrContext.nuxt.routePath = app.context.route.path;

  // Add meta infos (used in renderer.js)
  ssrContext.meta = _app.$meta();

  // Keep asyncData for each matched component in ssrContext (used in app/utils.js via this.$ssrContext)
  ssrContext.asyncData = {};
  const beforeRender = async () => {
    // Call beforeNuxtRender() methods
    await Promise.all(ssrContext.beforeRenderFns.map(fn => promisify(fn, {
      Components,
      nuxtState: ssrContext.nuxt
    })));
    ssrContext.rendered = () => {
      // Add the state from the vuex store
      ssrContext.nuxt.state = store.state;
    };
  };
  const renderErrorPage = async () => {
    // Don't server-render the page in static target
    if (ssrContext.target === 'static') {
      ssrContext.nuxt.serverRendered = false;
    }

    // Load layout for error page
    const layout = (nuxt_error.options || nuxt_error).layout;
    const errLayout = typeof layout === 'function' ? layout.call(nuxt_error, app.context) : layout;
    ssrContext.nuxt.layout = errLayout || 'default';
    await _app.loadLayout(errLayout);
    _app.setLayout(errLayout);
    await beforeRender();
    return _app;
  };
  const render404Page = () => {
    app.context.error({
      statusCode: 404,
      path: ssrContext.url,
      message: 'This page could not be found'
    });
    return renderErrorPage();
  };

  // Components are already resolved by setContext -> getRouteData (app/utils.js)
  const Components = getMatchedComponents(app.context.route);

  /*
  ** Dispatch store nuxtServerInit
  */
  if (store._actions && store._actions.nuxtServerInit) {
    try {
      await store.dispatch('nuxtServerInit', app.context);
    } catch (err) {
      console.debug('Error occurred when calling nuxtServerInit: ', err.message);
      throw err;
    }
  }
  // ...If there is a redirect or an error, stop the process
  if (ssrContext.redirected) {
    return noopApp();
  }
  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }

  /*
  ** Call global middleware (nuxt.config.js)
  */
  let midd = [];
  midd = midd.map(name => {
    if (typeof name === 'function') {
      return name;
    }
    if (typeof _nuxt_middleware[name] !== 'function') {
      app.context.error({
        statusCode: 500,
        message: 'Unknown middleware ' + name
      });
    }
    return _nuxt_middleware[name];
  });
  await middlewareSeries(midd, app.context);
  // ...If there is a redirect or an error, stop the process
  if (ssrContext.redirected) {
    return noopApp();
  }
  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }

  /*
  ** Set layout
  */
  let layout = Components.length ? Components[0].options.layout : nuxt_error.layout;
  if (typeof layout === 'function') {
    layout = layout(app.context);
  }
  await _app.loadLayout(layout);
  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }
  layout = _app.setLayout(layout);
  ssrContext.nuxt.layout = _app.layoutName;

  /*
  ** Call middleware (layout + pages)
  */
  midd = [];
  layout = sanitizeComponent(layout);
  if (layout.options.middleware) {
    midd = midd.concat(layout.options.middleware);
  }
  Components.forEach(Component => {
    if (Component.options.middleware) {
      midd = midd.concat(Component.options.middleware);
    }
  });
  midd = midd.map(name => {
    if (typeof name === 'function') {
      return name;
    }
    if (typeof _nuxt_middleware[name] !== 'function') {
      app.context.error({
        statusCode: 500,
        message: 'Unknown middleware ' + name
      });
    }
    return _nuxt_middleware[name];
  });
  await middlewareSeries(midd, app.context);
  // ...If there is a redirect or an error, stop the process
  if (ssrContext.redirected) {
    return noopApp();
  }
  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }

  /*
  ** Call .validate()
  */
  let isValid = true;
  try {
    for (const Component of Components) {
      if (typeof Component.options.validate !== 'function') {
        continue;
      }
      isValid = await Component.options.validate(app.context);
      if (!isValid) {
        break;
      }
    }
  } catch (validationError) {
    // ...If .validate() threw an error
    app.context.error({
      statusCode: validationError.statusCode || '500',
      message: validationError.message
    });
    return renderErrorPage();
  }

  // ...If .validate() returned false
  if (!isValid) {
    // Render a 404 error page
    return render404Page();
  }

  // If no Components found, returns 404
  if (!Components.length) {
    return render404Page();
  }

  // Call asyncData & fetch hooks on components matched by the route.
  const asyncDatas = await Promise.all(Components.map(Component => {
    const promises = [];

    // Call asyncData(context)
    if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {
      const promise = promisify(Component.options.asyncData, app.context);
      promise.then(asyncDataResult => {
        ssrContext.asyncData[Component.cid] = asyncDataResult;
        applyAsyncData(Component);
        return asyncDataResult;
      });
      promises.push(promise);
    } else {
      promises.push(null);
    }

    // Call fetch(context)
    if (Component.options.fetch && Component.options.fetch.length) {
      promises.push(Component.options.fetch(app.context));
    } else {
      promises.push(null);
    }
    return Promise.all(promises);
  }));

  // datas are the first row of each
  ssrContext.nuxt.data = asyncDatas.map(r => r[0] || {});

  // ...If there is a redirect or an error, stop the process
  if (ssrContext.redirected) {
    return noopApp();
  }
  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }

  // Call beforeNuxtRender methods & add store state
  await beforeRender();
  return _app;
});

/***/ })
/******/ ]);
//# sourceMappingURL=server.js.map